## 充分利用分片字段、二级分区字段
- 当where/on/group by等条件带上具体的分片字段、二级分区字段，SQL能仅访问对应分片、二级分区的数据，最小化对资源的利用，同时也很有可能能减小分布式事务的比例。
- 如对于TDSQL默认的hash分片而言，尽量使用确切的where分片字段条件，如部分范围查询shardkeycol between 1 and 10实际上可以转换成IN条件。

## 减少跨数据节点的JOIN，尽量使SQL能下推到存储层
- 如果涉及到多表频繁联合查询，这些表最好使用相同的shardkey，避免需要将数据加载到proxy层进行计算，减少数据访问的同时也可以提高效率。

## 避免全表扫描
### 最少使用一个左定索引访问数据
- 如a索引字段为字符串，以a like '%sfs%'为查询条件无法使用该索引，应当使用类似a like 'sfsfs%'等条件；
- 再如a,b为联合索引，以b='xxx'为查询条件无法使用该索引，应当使用a='xxx' and b like 'sfsfs%'等条件；

### 防止隐式转换
- 如a索引字段为整数，以a='1'为查询条件时，无法利用索引；应当使用a=1为条件；

### 不要在索引列上加函数，应当把索引列单独放在条件的一边
- 如a索引字段为datetime，以'2021-01-01' <= date_format(a,'%Y-%m-%d') and date_format(a,'%Y-%m-%d') < '2022-01-01' 为查询条件无法使用该索引；应当使用'2021-01-01 00:00:00' <= a and a < '2022-01-01 00:00:00'；

### in条件的值不应该太多，否则会使用全表扫描的方式
- 如避免where a in (大量值>1000个)等用法；

## 分页查询优化
- 对于翻页类需求，尽量使数据库只返回需要返回的结果集，一般不建议数据全返回后再在应用层排序筛选；
- 可以将多次翻页合并成一次翻页查询缓存在应用中，尤其是深度翻页时，尽可能每次缓存更多结果集；
- 对于数据库的分页，注意使用常用的分页SQL改写，如记录每次limit的最大最小唯一值，下次查询从该行标识作为与limit配合的where条件，避免深度分页性能差；再如先用覆盖索引等方式取出需要的行标识，然后再用IN条件查询需要的页。
