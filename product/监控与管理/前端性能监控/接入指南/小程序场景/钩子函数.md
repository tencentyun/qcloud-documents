您可以使用钩子函数对某些资源的测速上报进行自定义配置，系统将会为您计算、统计函数执行时间等。您可以在 [自定义测速](https://console.cloud.tencent.com/rum/web/custom) 多维度分析函数执行耗时。

## 钩子函数

### beforeReport

1. 该钩子将会在日志上报（对应上报接口为 /collect?）前执行，例如：
    <dx-codeblock>
    :::  js

  const aegis = new Aegis({
  id: 'pGUVFTCZyewxxxxx',
  beforeReport(log) {
  // 监听到下面抛出的错误
  console.log(log); // {level: "4", msg: "发生错误啦！！！！"}
  }
  });

  throw new Error('发生错误啦！！！！');:::
  </dx-codeblock>

>?上述`log` 将会有以下几个字段：  
>1. `level`: 日志等级，例如：当 level 为 '4' 时代表错误日志；  
>2. msg`: 日志内容；
>3. 全部日志等级如下：
> `{ level: '1', name: '接口请求日志（白名单日志）' },
> { level: '2', name: '一般日志' },
> { level: '4', name: 'JS 执行错误' },
> { level: '8', name: 'Promise 错误' },
> { level: '16', name: 'Ajax 请求异常' },
> { level: '32', name: 'JS 加载异常' },
> { level: '64', name: '图片加载异常' },
> { level: '128', name: 'css 加载异常' },
> { level: '256', name: 'console.error (未启用)' },
> { level: '512', name: '音视频资源异常' },
> { level: '1024', name: 'retcode 异常' },
> { level: '2048', name: 'aegis report' }`


2. 当该钩子返回 `false` 时，本条日志将不会进行上报，该功能可用来过滤某些不需要上报的错误，例如：
<dx-codeblock>
:::  js

   const aegis = new Aegis({
   id: 'pGUVFTCZyewxxxxx',
   beforeReport(log) {
   if(log.level === '4' && log.msg && log.msg.indexOf('碍眼的错误') !== -1) {
   return false
   }
   }
});
throw new Error('碍眼的错误'); // 该错误将不会被上报

</dx-codeblock>

上面例子中，当上报的错误内容包含 `碍眼的错误` 几个关键字时，将不会上报至 RUM 后台中。

### onReport

该钩子将在日志上报成功之后执行，用法类似 `beforeReport` 钩子，唯一不同点在于，该钩子接收到的所有参数都是已经上报完成的日志，而 `beforeReport` 钩子接收的参数是即将上报的日志。

### beforeReportSpeed

1. 该钩子将会在测速数据上报前被执行，例如：
<dx-codeblock>
:::  js

   const aegis = new Aegis({
   id: 'pGUVFTCZyewxxxxx',
   reportApiSpeed: true,
   reportAssetSpeed: true,
   beforeReportSpeed(msg) {
   console.log(msg); // {url: "https://localhost:3001/example.e31bb0bc.js", method: "get", duration: 7.4, status: 200, type: "static"}
   return msg
}
});:::
</dx-codeblock>


>?上述 `msg` 将会有以下几个字段：  
1. `url`: 该资源的请求地址；  
2. `type`: 该资源的类型，目前有 `fetch` 、 `static` 两种，当为 `fetch` 时，Aegis 将会把该资源当成 API 请求进行上报，`static` 时则视为静态资源；  
3. `duration`: 该资源请求耗时；  
4. `method`: 请求该资源时使用的 `http method`；  
5. `status`: 服务器返回状态码；  

上面的例子中，每当 Aegis 收集到一个资源的加载详情时，将会以该资源的加载情况（上面的返回的`msg`）作为参数调用 `beforeReportSpeed` 钩子。  

2. 如果您配置了该钩子，**Aegis 最终的上报内容将以钩子的执行结果为准**。例如：

<dx-codeblock>
:::  js
const aegis = new Aegis({
id: 'pGUVFTCZyewxxxxx',
reportApiSpeed: true,
reportAssetSpeed: true,
beforeReportSpeed(msg) {
msg.type = 'static';
}
});
:::
</dx-codeblock>

步骤2的代码中，将所有的 `msg.type` 设置为 `static`，这意味着所有的资源都将被当成静态资源进行上报，API 请求也将被报至静态资源中。  

3. 使用该钩子，您可以校准 Aegis 类型判断错误的请求。  
举例说明：假如您有一条接口 `https://example.com/api`，该接口的响应头 `Content-Type` 为 `text/html`。正常情况下，RUM 会将该资源当成静态资源进行上报。但在您的业务中，该接口就必须视为 API 请求进行上报，您可以给 aegis 配置如下钩子进行校正：

<dx-codeblock>
:::  js
const aegis = new Aegis({
id: 'pGUVFTCZyewxxxxx',
reportApiSpeed: true,
reportAssetSpeed: true,
beforeReportSpeed(msg) {
if(msg.url === 'https://example.com/api') {
msg.type = 'fetch';
}
}
});

:::
</dx-codeblock>

4. 您还可以屏蔽某些资源的测速上报，例如：

<dx-codeblock>
:::  js
const aegis = new Aegis({
    id: 'pGUVFTCZyewxxxxx',
    reportApiSpeed: true,
    reportAssetSpeed: true,
    beforeReportSpeed(msg) {
        // 地址中包含‘https://example.com/api’的都不上报
        if (msg.url.indexOf('https://example.com/api') !== -1) {
            // 返回 ‘false’ 将阻止本条测速日志的上报
            return false
        }
    }
});
:::
</dx-codeblock>

