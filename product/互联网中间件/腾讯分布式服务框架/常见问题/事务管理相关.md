### 在事务协调器故障时，事务的提交和回滚还能正常进行吗?
事务协调器采用无状态节点，只要没有全部故障，就能够正常运行业务（性能会受到影响）。若节点全部故障，事务的提交和回滚也不受影响，重启服务后，事务仍能够正常提交或回滚。

### 在 TCC（MT）模式中，Confirm 和 Cancel 可能和 Try 并行甚至在 Try 之前执行吗？
可能出现。可能的场景如下：

场景一：空回滚问题（Try 未执行时，Cancel 执行）
- 解决空回滚问题的方案：Cancel 操作判断一阶段是否已执行，识别空回滚后，直接返回成功；具体来讲：需要一张额外的事务控制表，其中有分布式事务 ID 和分支事务 ID，第一阶段 Try 方法里会插入一条记录，表示一阶段执行了。Cancel 接口里读取该记录，如果该记录存在，则正常回滚；如果该记录不存在，则是空回滚。

场景二：悬挂问题（Try 超时，执行 Cancel，Try 接口恢复）
- 出现悬挂问题的原因：Try 由于网络拥堵而超时，事务管理器生成回滚，触发 Cancel 接口，而最终又收到了 Try 接口调用，但是 Cancel 比 Try 先到。
- 解决悬挂问题的方案：按照前面允许空回滚的逻辑，回滚会返回成功，事务管理器认为事务已回滚成功，则此时的 Try 接口不应该执行，否则会产生数据不一致，所以我们在 Cancel 空回滚返回成功之前先记录该条事务 xid 或业务主键，标识这条记录已经回滚过，Try 接口先检查这条事务 xid 或业务主键如果已经标记为回滚成功过，则不执行 Try 的业务操作。

### 在 TCC（MT）模式中，是否需要考虑幂等？
需要考虑幂等问题。
幂等问题的解决方案为：DTF 框架会在 Confirm 和 Cancel 执行后将事务状态改为已提交或已回滚状态，因此，重复调用在 Confirm 和 Cancel 接口时，先获取状态，如果已执行，直接返回成功。

### 如果调用链为 A->B->C，B.try 报错，A.cancel，B.cancel，C.cancel 哪些会执行？
A 和 B 会执行，先 B 然后 A。

### 如果 Confirm 或者 Cancel 报错，重试机制是怎样的？
会有**三次重试**。第一次 Confirm 或 Cancel（非重试），持续15分钟。若超时，在1秒后开始第一次重试，持续15分钟；若依然超时，等待2秒开始第二次重试，持续15分钟；若还是超时，等待3秒开始第三次重试15分钟。若依然失败，则转为异常事务。

### 如果 try 超时了，框架是否会回滚 try 的本地事务并阻止后续调用链？
会回滚，需要注意实现幂等以及防悬挂可空回滚。会阻止后续调用。
