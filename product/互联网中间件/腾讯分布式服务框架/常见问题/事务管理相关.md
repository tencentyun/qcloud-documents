### 在事务协调器故障的情况下，事务的提交和回滚还能正常进行吗?
事务协调器采用无状态节点，只要没有全部故障，就能够正常运行业务（性能会受到影响）。若节点全部挂掉，事务的提交和回滚也不受影响，重启服务后，事务仍能够正常提交或回滚。

### 在TCC(MT)模式中，confirm和cancel可能和try并行甚至在try之前执行吗？
可能出现。
例如空回滚问题：try 未执行时，cancel 执行。
解决空回滚问题的方案是：Cancel 操作判断一阶段是否已执行，识别空回滚后，直接返回成功；具体来讲：需要一张额外的事务控制表，其中有分布式事务 ID 和分支事务 ID，第一阶段 Try 方法里会插入一条记录，表示一阶段执行了。Cancel 接口里读取该记录，如果该记录存在，则正常回滚；如果该记录不存在，则是空回滚。
另外，还有悬挂问题：try 超时，执行cancel，try 接口恢复。出现的原因是 Try 由于网络拥堵而超时，事务管理器生成回滚，触发 Cancel 接口，而最终又收到了 Try 接口调用，但是 Cancel 比 Try 先到。
解决悬挂问题的方案是：按照前面允许空回滚的逻辑，回滚会返回成功，事务管理器认为事务已回滚成功，则此时的 Try 接口不应该执行，否则会产生数据不一致，所以我们在 Cancel 空回滚返回成功之前先记录该条事务 xid 或业务主键，标识这条记录已经回滚过，Try 接口先检查这条事务xid或业务主键如果已经标记为回滚成功过，则不执行 Try 的业务操作。

### 在TCC(MT)模式中，是否需要考虑幂等？
需要考虑幂等问题。
幂等问题的解决方案为：DTF框架会在 Confirm 和 Cancel 执行后将事务状态改为已提交或已回滚状态，因此，重复调用在 Confirm 和 Cancel 接口时，先获取状态，如果已执行，直接返回成功。

### 如果调用链为 A-》B-》C，B.try报错，A.cancel，B.cancel，C.cancel哪些会执行？
A和B会执行，先B然后A

### 如果confirm或者cancel报错，重试机制是怎样的？
会有三次重试。第一次confirm或cancel（非重试），持续15分钟。若超时，在1秒后开始第一次重试，持续15分钟；若依然超时，等待2秒开始第二次重试，持续15分钟；若还是超时，等待3秒开始第三次重试15分钟。若依然失败，则转为异常事务。

### 如果try超时了，框架是否会回滚try的本地事务并阻止后续调用链？
会回滚，需要注意实现幂等以及防悬挂可空回滚。会阻止后续调用。
