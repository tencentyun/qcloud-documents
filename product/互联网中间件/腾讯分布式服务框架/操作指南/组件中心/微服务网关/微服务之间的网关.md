
## 使用场景

通常在一个微服务系统中，会有两个位置使用微服务网关：

- 微服务系统的边界，如前端与微服务后台之间的网关。

  ![](https://main.qcloudimg.com/raw/c121001e9fe7b7e0a6fefede43ff9360.svg)

- 不同的微服务业务系统之间，如不同部门的业务后台都使用微服务架构，不同系统之间通过微服务网关进行调用；开发环境和预发布环境的业务都希望通过微服务网关访问某一个公共接口。在 set 化部署和单元化架构部署中，也常常通过微服务网关做不同业务系统之间访问的桥梁。在这类场景中，通常都希望不同系统之间的访问安全可控：不同系统之间进行物理或逻辑的隔离，通过网关实现“最小必须”的访问。

  ![](https://main.qcloudimg.com/raw/316db4e2d0196fd6538226b0f8004db1.svg)

在腾讯微服务平台（TSF）中，我们通过命名空间来实现不同业务系统的访问逻辑隔离，本文就和您介绍下如何使用命名空间和微服务网关实现不同微服务业务系统之间的调用。

## 微服务网关与命名空间

在 [命名空间](https://cloud.tencent.com/document/product/649/15522) 中，我们介绍了 TSF 中的两种命名空间：全局命名空间与非全局命名空间。其中，

- 不同非全局命名空间（包含系统命名空间）中部署的微服务不能直接相互调用。
- 全局命名空间中的微服务可以被其他命名空间中的微服务调用（典型场景：公共服务），但是不能调用其他命名空间中的微服务。

微服务网关也可以部署在全局命名空间和非全局命名空间中。在实际使用中，用户创建微服务网关应用下的部署组时，可以选择是否将网关部署在全局命名空间中。不同命名空间与微服务网关的关系如下：

| 部署位置       | 网关调用其他微服务                         | 其他微服务调用网关                                           |
| -------------- | ------------------------------------------ | ------------------------------------------------------------ |
| 全局命名空间   | 微服务网关可以调用所有命名空间中的微服务   | 微服务网关可以被所有微服务调用                               |
| <nobr>非全局命名空间</nobr> | 微服务网关仅可以调用所在命名空间下的微服务 | 可以被所在命名空间中的微服务调用（常见）或被全局命名空间中的网关调用（少见） |

示意图如下：

- 普通命名空间中的微服务网关：

 ![](https://main.qcloudimg.com/raw/83d7350157f973ac1e4ec46a702849a3.svg)

- 全局命名空间中的微服务网关：

 ![](https://main.qcloudimg.com/raw/8a4e8e8656b32a9638cbaf0964087940.svg)

用户可以通过全局命名空间中的微服务网关达到跨命名空间访问的目的。非全局命名空间1中的微服务调用全局命名空间中的微服务网关调用另一个非全局命名空间中的微服务。此时，全局命名空间中的网关就是不同非全局命名空间中微服务调用的桥梁。在实际的业务场景中，您可以将不同部门的业务部署在不同的命名空间中，通过全局命名空间的微服务网关来进行跨部门的调用。

## 调用方法

**网关调用微服务**

微服务网关调用微服务时，用户可以通过网关托管 API 的路径进行调用。访问路径如下：IP 或域名/分组 context/命名空间名/微服务名/API 路径。访问路径规则与网关是否部署在全局命名空间中无关，但当微服务网关部署在非全局命名空间中，访问路径中却填写了错误命名空间名，则访问不通。

**微服务调用网关**

用户可以通过网关的服务名调用网关。当非全局命名空间 namespace1 中的微服务 consumer 希望通过全局命名空间中的网关 zuul 访问 namespace2 中的微服务 provider 时，可以在 consumer 中直接访问微服务 zuul，访问路径为 `/context/namespace2/provider/api-path`。

示例代码如下:

```
// 下面省略了无关的代码
import org.springframework.web.client.RestTemplate;

@RestController
public class ConsumerController {
	@Autowired
	private RestTemplate restTemplate;

	@RequestMapping(value = "/echo-rest/{str}", method = RequestMethod.GET)
	public String restProvider(@PathVariable String str,
							   @RequestParam(required = false) String tagName,
							   @RequestParam(required = false) String tagValue) {
		return restTemplate.getForObject("http://scg-demo/context/namespace2/provider/echo/" + str, String.class);
	}

}
```

