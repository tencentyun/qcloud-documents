##  Collaborative Filtering
协同过滤是经典的基于邻域的推荐算法，平台上的协同过滤算法是通过 ALS 的矩阵分解优化求解的。

#### 训练节点
  - 输入
    - 数据形式：Dense 或 Libsvm
    - 格式：| User | Item | Rating |
    - User：User 所在列，通过**算法参数**中的 User 列指定。
    - Item：Item 所在列，通过**算法参数**中的 Item 列指定。
    - Rating：评分所在列的列号，通过**算法参数**中的 Rating 列指定。
  - 输出
    - PMML 格式的模型。
    - **userPath：|id|features|**
      - id：用户 ID。
      - features：用户的特征向量。
    - **itemPath：|id|features|**
      - id：商品 ID。
      - features：商品的特征向量。
  - 算法参数
    - User 列：User 所在列，从0开始计数。
    - Item 列：Item 所在列的列号，从0开始计数。
    - Rating 列：评分所在列的列号，从0开始计数。
    - 隐变量数：矩阵变换中隐变量的个数，推荐值：10-200。
    - 正则系数：正则项系数，推荐值：0.01。
    - 最大迭代次数：最大迭代次数，推荐值：10-20。
    - 反馈方式：隐性反馈与显性反馈方式。
    - 是否使用非负的限制：是否对最小二乘法使用非负的限制。
    - 偏好行为强度的基准：专门针对隐性反馈的参数，决定了偏好行为强度的基准
    - 并行数：训练数据的分区数、Spark 的并行数。
    - 抽样率：输入数据的采样率。

#### 预测节点*
  - 输入
    - 格式：| User | Item |
    - 说明：以空格连接各字段。
    - User：同训练节点。
    - Item：同训练节点。
  - 输出
    - 格式：| 原始数据 | ratings |
    - 说明：以空格连接各字段。
    - ratings:预测的评分。




##  Matrix Factorization On Angel
Matrix Factorizaiton（MF）是推荐系统中常用的矩阵分解算法，将用户、商品抽象为 K 维向量，将用户-商品矩阵分解为用户矩阵和商品矩阵的乘积。
MF 的主要思想是把用户、商品的特征抽象为k维向量表示。  
用户-商品评分矩阵（简称评分矩阵），是推荐系统中常用的数据表示方法，用一个矩阵表示用户对商品的打分。矩阵的每行代表一个用户，每列代表一个商品，每个元素代表对应用户对商品的评分，如图一所示。在大多数情况下商品数量巨大，每个用户只对极小部分商品有评分，所以评分矩阵一般非常稀疏，即评分矩阵中的绝大多数元素为0。MF 算法把评分矩阵分解为用户-特征矩阵（简称用户矩阵）和特征-商品矩阵（简称商品矩阵）。   

|          | 商品1 | 商品2 | 商品3 | 商品4 |
|---------|---------|---------|--------|---------|
| 用户1  |    4    |      5   |   1    |     -     |  
| 用户2  |   -      |      -   |   3    |     4     |
| 用户3  |    -     |      2   |   -    |      -    |
| 用户4  |    5    |      -   |   1    |      1     |
| 用户5  |    -     |      -   |   1    |     -      |
| 用户6  |    3     |      4   |   -    |      -     |

假设数据集有 M 个用户，N 个商品：评分矩阵用 Y 表示，Y 的维度为：M × N，y_{ij} 表示第 i 个用户对第 j 个商品的评分。
MF 算法把评分矩阵 Y 分解为用户矩阵 U 和商品矩阵 V 的乘积，U 的维度为 M × k，每一行代表一个用户 u_i，u_i 是一个 k 维特征向量；V 的维度为 k × N，每一列代表一个商品 v_j，v_j 是一个 k 维特征向量；k 是 MF 算法指定的值，代表特征向量的维度。我们以用户向量 u_i 和商品向量 v_j 的乘积作为用户 i 对商品j评分的预测值，记为 y_{ij}，如下图所示：  
![](https://main.qcloudimg.com/raw/7f4e18ce3524570f1e5e4e4edb9ed6c6.png)


### Gradient Descent Matrix Factorizaion
用户 i 对商品j的实际评分为 y_{ij} 预测值与真实值之差记为 e_{ij}，即：e_{ij} = y{ij}-u_i \cdot v_j。
MF算法的学习目标是最小化预测评分与真实评分之间的差距：
![](https://main.qcloudimg.com/raw/1ad309cc286fe200a7ef4c2205aa8b1f.png)

为了防止模型过拟合，加入 L2 正则项：
![](https://main.qcloudimg.com/raw/abcab11f51abc93624874aa12b134eda.png)

其中，<img src="https://main.qcloudimg.com/raw/931b2dcdf82ebd22ac6b3cf2f559d3c6.png" style="margin:0;">用梯度下降法最小化目标函数，得到用户特征向量 u_i、商品特征向量 v_j 的更新公式为：  
![](https://main.qcloudimg.com/raw/30784e9d795640767232eba706a10d7f.png)    ![](https://main.qcloudimg.com/raw/6a96c664f1020d4438b1c89c20981740.png)


#### 模型存储
商品矩阵存放在PS，用户矩阵存放在Worker，PS和Worker间传输商品矩阵V即可，不需要传输用户矩阵U。

由用户向量的更新公式可知，用户向量的计算只和这个用户的评分数据有关，用户间相互独立，因此我们把用户矩阵U按照用户切分成多个子块存储在多个Worker，每个Worker只计算自己训练数据相关的用户的向量，记为：U-part，维度是：这个Worker分配到的用户数×k。

#### 模型计算
Angel 用梯度下降法学习 MF 模型，为了减少计算量和网络通信、提高计算效率，对算法做了以下设计：
因为商品向量的计算只和对它的评分相关，Worker 上的训练数据可能只包含商品集合中的一部分商品的评分信息，该 Worker 只能计算出这部分商品向量的梯度值，对无评分的商品计算的梯度值永远等于0，所以每次迭代只从 PS 拉取有评分的商品的向量即可，是整个商品矩阵的一个子集，记为 V-sub 矩阵。

当商品数量很大且 k 是一个比较大的值时，V-sub 矩阵仍然可能超过了单个 Worker的内存，而商品向量之间的更新相互独立，所以我们设计分批更新V-sub矩阵。每次迭代分成多个批计算，每批只从 PS 获取 V-sub 的一部分，用这部分商品向量更新 Worker 的用户矩阵，计算这部分商品向量的更新值推送给 PS。
![](https://main.qcloudimg.com/raw/36712f45fe34bf44092ff5a0c34ddaef.png)

#### 算法逻辑
Matrix Factorization on Angel 的算法逻辑如下所示：
![](https://main.qcloudimg.com/raw/d6587679ebef1fa8762c0c69f2f9e80a.png)

MF 训练数据的格式：`用户ID，商品ID：评分，…，商品：评分`

一个用户的所有评分存储在一行。如下图所示：
![](https://main.qcloudimg.com/raw/dd2d7c63b7d6ed751e60a39775878135.png)
ID 为0的用户对 ID 为1、66、99、1001的商品评分分别为4、2、4、1。
ID 为1的用户对 ID 为77的商品评分为3。

输入（训练节点）：
   * angel.train.data.path：输入数据路径。
   * angel.save.modelPath：商品特征矩阵保存路径。
   * angel.ml.mf.usermodel.output：用户特征矩阵保存路径。
   * angel.log.path：LOG 保存路径。

输出（训练节点）：
   * 模型格式：| mf_item_model |，二进制格式。
   * mf_item_model：每一行对应一个商品特征向量。

算法参数（训练节点）：
   * ml.mf.rank：用户、商品特征向量的维度。
   * ml.mf.item.num：商品数量。
   * ml.mf.lambda：正则化系数。
   * ml.mf.eta：学习速率。
   *  ml.mf.row.batch.num：每次迭代的 batch 数。
    

## ALS 算法
#### 算法说明
ALS（alternating least squares）算法是交替最小二乘的简称。在机器学习中，ALS 特指使用交替最小二乘求解的一个协同推荐算法。它通过观察到的所有用户给商品的打分，来推断每个用户的喜好并向用户推荐适合的商品。
从广义上讲，推荐系统基于两种不同的策略：基于内容的方法和基于协同过滤的方法。Spark 中使用协同过滤的方式。协同过滤分析用户以及用户相关的产品的相关性，用以识别新的用户-产品相关性。协同过滤系统需要的唯一信息是用户过去的行为信息，比如对产品的评价信息。协同过滤是领域无关的，所以它可以方便解决基于内容方法难以解决的许多问题。
推荐系统依赖不同类型的输入数据，最方便的是高质量的显式反馈数据，它们包含用户对感兴趣商品明确的评价。例如，Netflix收集的用户对电影评价的星星等级数据。但是显式反馈数据不一定总是找得到，因此推荐系统可以从更丰富的隐式反馈信息中推测用户的偏好。 隐式反馈类型包括购买历史、浏览历史、搜索模式甚至鼠标动作。例如，购买同一个作者许多书的用户可能喜欢这个作者。
  许多研究都集中在处理显式反馈，然而在很多应用场景下，应用程序重点关注隐式反馈数据。因为可能用户不愿意评价商品或者由于系统限制我们不能收集显式反馈数据。在隐式模型中，一旦用户允许收集可用的数据，在客户端并不需要额外的显式数据。
Spark利用交换最小二乘解决矩阵分解问题分两种情况：数据集是显式反馈和数据集是隐式反馈。

[算法示例](https://tio.cloud.tencent.com/ml/platform.html?projectId=4265&flowId=13370)

#### 训练节点
 - 输入
    - 输入数据路径：输入训练文件所在路径。
    - 输入数据格式：每行样本的各列以空格连接，如10.2 12.8 3.67。
 - 参数
    - User 列：User 所在列，从0开始计数。
    - Item 列：Item 所在列的列号，从0开始计数。
    - Rating 列：评分所在列的列号，从0开始计数。
    - 隐变量数：矩阵变换中隐变量的个数，推荐值：10-200。
    - 正则系数：正则项系数，推荐值：0.01。
    - 最大迭代次数：最大迭代次数，推荐值：10-20。
    - 反馈方式：隐性反馈与显性反馈方式。
    - 是否使用非负的限制：是否对最小二乘法使用非负的限制。
    - 偏好行为强度的基准：专门针对隐性反馈的参数，决定了偏好行为强度的基准。

#### 预测节点
 - 输入
    - 输入数据路径：输入测试文件所在路径。
    - 输入数据格式：每行样本的各列以空格连接，如10.2 12.8 3.67 …。
 - 输出
    - 输出数据路径：经转换后的测试数据存储路径。
    - 输出数据格式：每行样本的各列以空格连接，如1 0 1 0 …。最后的结果中，会 append 一列预测的 rating 值。
 - 参数
    - User 列：User 所在列，从0开始计数。
    - Item 列：Item 所在列的列号，从0开始计数。



