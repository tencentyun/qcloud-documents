## 5.1	DBMS_RANDOM ##
DBMS_RANDOM 包用于产生随机值。DBMS_RANDOM 中可以使用的存储过程及函数如下表所示：

|存储过程/函数|	描述|
|--|--|
|*INITIALIZE	|用一个种子值来初始化 DBMS_RANDOM。|
|NORMAL	|返回服从正态分布的一组数。|
|*RANDOM| 返回值的范围为： [-2^31, 2^31)，返回的是整数。 |
|*SEED	|功能和 INITIALIZE 函数类似，实际上，INITIALIZE 函数被淘汰，推荐的替代函数即是 SEED 函数。与 INITIALIZE 函数不同的是 SEED 函数同时支持数值和字符作为种子值，而 INITIALIZE 函数只支持数值。|
|*STRING	|随机生成字符串。|
|*TERMINATE	|在使用完 DBMS_RANDOM 包后，用该函数进行终止。|
|*VALUE	|随机返回数值。|

示例：

    Create table random_t1(col1 int,col2 numeric,col3 numeric,col4 numeric,col5  numeric);
    Create table random_t2 as select * from random_t1;
    begin
    perform dbms_random.initialize(100);
    for i in 1..100 loop
    insert into random_t1 values(i,dbms_random.normal(),dbms_random.random(),dbms_random.value(),dbms_random.value(10,20));
    end loop;
    end;
    /
    begin
    perform dbms_random.initialize(100);
    for i in 1..100 loop
    insert into random_t2 values(i,dbms_random.normal(),dbms_random.random(),dbms_random.value(),dbms_random.value(10,20));
    end loop;
    end;
    /
    select * from random_t1 minus select * from random_t2;
    Drop table if exists random_t1;
    Drop table if exists random_t2;

## 5.2	DBMS_SQL ##
DBMS_SQL 可以在应用的运行时间构建查询和其它的命令。DBMS_SQL中可以使用的存储过程及函数如下表所示：

|存储过程/函数|	描述|
|--|--|
|BIND_VARIABLE(c, name, value [, out_value_size ])	| 将一个值与一个变量绑定。           |
|BIND_VARIABLE_CHAR(c, name, value [, out_value_size ])| 将一个 CHAR 值与一个变量绑定。 |
|BIND_VARIABLE_RAW(c, name, value [, out_value_size ])	|将一个 RAW 值与一个变量绑定。|
|CLOSE_CURSOR(c IN OUT)| 关闭一个游标。                     |
|COLUMN_VALUE(c, position, value OUT [, column_error OUT [, actual_length OUT ]])| 返回一个列的值到一个变量中。 |
|COLUMN_VALUE_CHAR(c, position, value OUT [, column_error OUT [, actual_length OUT ]])| 返回一个 CHAR 列的值到一个变量中。 |
|COLUMN_VALUE_RAW(c, position, value OUT [, column_error OUT [, actual_length OUT ]])| 返回一个 RAW 列的值到一个变量中。 |
|DEFINE_COLUMN(c, position, column [, column_size ])	|在 SELECT 列表中定义一个列。|
|DEFINE_COLUMN_CHAR(c, position, column, column_size)	|在SELECT列表中定义一个 CHAR 列。|
|DEFINE_COLUMN_RAW(c, position, column, column_size)	|在SELECT列表中定义一个 RAW 列。|
|DESCRIBE_COLUMNS| 定义用于存放游标结果集的列。 |
|EXECUTE(c)	|执行一个游标。|
|EXECUTE_AND_FETCH(c [, exact ])	|执行一个游标并获取一条记录。|
|FETCH_ROWS(c)|从游标中获取记录。|
|IS_OPEN(c)| 检查游标是否已经开启。 |
|LAST_ROW_COUNT	|返回获取的累积记录数。|
|OPEN_CURSOR	|开启一个游标。|
|PARSE(c, statement, language_flag)	|解析一条语句。|

示例：    
    set client_min_messages TO error;
    CREATE EXTENSION IF NOT EXISTS dbms_sql;
    set client_min_messages TO default;
    
    do
    $$
    declare
    c  int;
    strval varchar;
    intval int;
    nrows  int default 30;
    begin
    c := dbms_sql.open_cursor();
    call dbms_sql.parse(c, 'select ''ahoj'' || i, i from generate_series(1, :nrows) g(i)');
    call dbms_sql.bind_variable(c, 'nrows', nrows);
    call dbms_sql.define_column(c, 1, strval);
    call dbms_sql.define_column(c, 2, intval);
    perform dbms_sql.execute(c);
    while dbms_sql.fetch_rows(c) > 0
    loop
    call dbms_sql.column_value(c, 1, strval);
    call dbms_sql.column_value(c, 2, intval);
    raise notice 'c1: %, c2: %', strval, intval;
    end loop;
    call dbms_sql.close_cursor(c);
    end;
    $$;
    
    do
    $$
    declare
    c  int;
    strval varchar;
    intval int;
    nrows  int default 30;
    begin
    c := dbms_sql.open_cursor();
    call dbms_sql.parse(c, 'select ''ahoj'' || i, i from generate_series(1, :nrows) g(i)');
    call dbms_sql.bind_variable(c, 'nrows', nrows);
    call dbms_sql.define_column(c, 1, strval);
    call dbms_sql.define_column(c, 2, intval);
    perform dbms_sql.execute(c);
    while dbms_sql.fetch_rows(c) > 0
    loop
    strval := dbms_sql.column_value_f(c, 1, strval);
    intval := dbms_sql.column_value_f(c, 2, intval);
    raise notice 'c1: %, c2: %', strval, intval;
    end loop;
    call dbms_sql.close_cursor(c);
    end;
    $$;
    
    create table foo
    (
    a int,
    b varchar,
    c numeric
    );
    
    do
    $$
    declare
    c int;
    begin
    c := dbms_sql.open_cursor();
    call dbms_sql.parse(c, 'insert into foo values(:a, :b, :c)');
    for i in 1..100
    loop
    call dbms_sql.bind_variable(c, 'a', i);
    call dbms_sql.bind_variable(c, 'b', 'Ahoj ' || i);
    call dbms_sql.bind_variable(c, 'c', i + 0.033);
    perform dbms_sql.execute(c);
    end loop;
    end;
    $$;
    
    select *
    from foo
    order by a;
    truncate foo;
    
    do
    $$
    declare
    c int;
    begin
    c := dbms_sql.open_cursor();
    call dbms_sql.parse(c, 'insert into foo values(:a, :b, :c)');
    for i in 1..100
    loop
    perform dbms_sql.bind_variable_f(c, 'a', i);
    perform dbms_sql.bind_variable_f(c, 'b', 'Ahoj ' || i);
    perform dbms_sql.bind_variable_f(c, 'c', i + 0.033);
    perform dbms_sql.execute(c);
    end loop;
    end;
    $$;
    
    select *
    from foo
    order by a;
    truncate foo;
    
    do
    $$
    declare
    c  int;
    a  int[];
    b  varchar[];
    ca numeric[];
    begin
    c := dbms_sql.open_cursor();
    call dbms_sql.parse(c, 'insert into foo values(:a, :b, :c)');
    a := ARRAY [1, 2, 3, 4, 5];
    b := ARRAY ['Ahoj', 'Nazdar', 'Bazar'];
    ca := ARRAY [3.14, 2.22, 3.8, 4];
    
    call dbms_sql.bind_array(c, 'a', a);
    call dbms_sql.bind_array(c, 'b', b);
    call dbms_sql.bind_array(c, 'c', ca);
    raise notice 'inserted rows %', dbms_sql.execute(c);
    end;
    $$;
    
    select *
    from foo
    order by a;
    truncate foo;
    
    do
    $$
    declare
    c  int;
    a  int[];
    b  varchar[];
    ca numeric[];
    begin
    c := dbms_sql.open_cursor();
    call dbms_sql.parse(c, 'insert into foo values(:a, :b, :c)');
    a := ARRAY [1, 2, 3, 4, 5];
    b := ARRAY ['Ahoj', 'Nazdar', 'Bazar'];
    ca := ARRAY [3.14, 2.22, 3.8, 4];
    
    call dbms_sql.bind_array(c, 'a', a, 2, 3);
    call dbms_sql.bind_array(c, 'b', b, 3, 4);
    call dbms_sql.bind_array(c, 'c', ca);
    raise notice 'inserted rows %', dbms_sql.execute(c);
    end;
    $$;
    
    select *
    from foo
    order by a;
    truncate foo;
    
    do
    $$
    declare
    c  int;
    a  int[];
    b  varchar[];
    ca numeric[];
    begin
    c := dbms_sql.open_cursor();
    call dbms_sql.parse(c, 'select i, ''Ahoj'' || i, i + 0.003 from generate_series(1, 35) g(i)');
    call dbms_sql.define_array(c, 1, a, 10, 1);
    call dbms_sql.define_array(c, 2, b, 10, 1);
    call dbms_sql.define_array(c, 3, ca, 10, 1);
    
    perform dbms_sql.execute(c);
    while dbms_sql.fetch_rows(c) > 0
    loop
    call dbms_sql.column_value(c, 1, a);
    call dbms_sql.column_value(c, 2, b);
    call dbms_sql.column_value(c, 3, ca);
    raise notice 'a = %', a;
    raise notice 'b = %', b;
    raise notice 'c = %', ca;
    end loop;
    call dbms_sql.close_cursor(c);
    end;
    $$;





## 5.3	DBMS_STATS ##
DBMS_STATS 能良好地估计统计数据（尤其是针对较大的分区表），并能获得更好的统计结果，最终制定出速度更快的 SQL 执行计划。包含以下接口：

|接口|	描述|
|--|--|
|GATHER_DATABASE_STATS	|分析数据库，包括所有用户对象和系统对象。|
|GATHER_TABLE_STATS| 分析表。 |
|GET_COLUMN_STATS	|取得列的统计信息。|
|GET_INDEX_STATS| 取得索引的统计信息。 |
|GET_TABLE_STATS	|取得表的统计信息。|
示例：

    CREATE EXTENSION IF NOT EXISTS tbase_oracle_package_function;
    
    create user godlike_dbms_stats superuser;
    create user joe;
    create user no_privilege;
    
    \c postgres godlike_dbms_stats
    grant usage on schema dbms_stats to no_privilege;
    grant usage on schema dbms_stats to joe;
    
    \c postgres joe
    -- table joe_t
    create table joe_t (id integer not null PRIMARY KEY, test integer);
    create index joe_t_test_idx on joe_t(test);
    insert into joe_t SELECT generate_series(1,1000) as key, (random()*(10^3))::integer;
    
    \c postgres joe
    exec dbms_stats.gather_table_stats(ownname => 'joe',tabname => 'joe_t');
    exec dbms_stats.get_table_stats(ownname => 'joe',tabname => 'joe_t');
    exec dbms_stats.get_column_stats('joe', 'joe_t', 'test');
    exec dbms_stats.get_index_stats('joe', 'joe_t_test_idx');
    
    -- table joe_t_p
    create table joe_t_p (id integer not null PRIMARY KEY, test integer) partition by range (id) begin (1) step (5) partitions (200) distribute by shard(id);
    create index joe_t_p_test_idx on joe_t_p(test);
    insert into joe_t_p SELECT generate_series(1,1000) as key, (random()*(10^3))::integer;
    
    exec dbms_stats.gather_database_stats();
    exec dbms_stats.get_table_stats(ownname => 'joe',tabname => 'joe_t_p');
    exec dbms_stats.get_column_stats('joe', 'joe_t_p', 'test');
    exec dbms_stats.get_index_stats('joe', 'joe_t_p_test_idx');
    exec dbms_stats.get_table_stats('joe', 'joe_t_p', 'joe_t_p_part_0');
    exec dbms_stats.get_index_stats('joe', 'joe_t_p_test_idx', 'joe_t_p_test_idx_part_0');
    
    -- clean
    \c postgres godlike_dbms_stats
    drop table joe_t;
    drop table joe_t_p;
    REVOKE usage ON schema dbms_stats FROM joe;
    REVOKE usage ON schema dbms_stats FROM no_privilege;
    drop user joe;
    drop user no_privilege;

## 5.4	DBMS_LOB ##
DBMS_LOB 用于在大对象上进行操作。DBMS_LOB 包提供了子程序可以在 BLOB、CLOB、NCLOB、BFILE 和临时 LOB 上操作的子程序。使用DBMS_LOB 可以访问和处理 LOB 的特定部分或全部。

|存储过程/函数|	描述|
|--|--|
|APPEND(dest_lob IN OUT,src_lob)	|将一个大对象追加到另一个对象。|
|COMPARE(lob_1, lob_2 [, amount[, offset_1 [, offset_2 ]]])	|比较两个大对象。|
|CONVERTOBLOB(dest_lob IN OUT,src_clob, amount, dest_offsetIN OUT, src_offset IN OUT,blob_csid, lang_context IN OUT,warning OUT)	|将字符数据转换为二进制数据。|
|CONVERTTOCLOB(dest_lob IN OUT,src_blob, amount, dest_offsetIN OUT, src_offset IN OUT,blob_csid, lang_context IN OUT,warning OUT)	| 将二进制数据转换为字符数据。                        |
|COPY(dest_lob IN OUT, src_lob,amount [, dest_offset [,src_offset ]])	| 将一个大对象复制到另一个对象。                      |
|ERASE(lob_loc IN OUT, amount IN OUT [, offset ])	|清除一个大对象。|
|GET_STORAGE_LIMIT(lob_loc)	|获取大对象的存储限制。|
|GETLENGTH(lob_loc)	| 获取大对象的长度。                                  |
|INSTR(lob_loc, pattern [,offset [, nth ]])	|获取大对象中从 `offset` 开始模式第 n 次出现的位置。|
|READ(lob_loc, amount IN OUT,offset, buffer OUT)	|读取一个大对象。|
|SUBSTR(lob_loc [, amount [,offset ]])| 获取一个大对象的一部分。 |
|TRIM(lob_loc IN OUT, newlen)	|将一个大对象裁剪到指定长度。|
|WRITE(lob_loc IN OUT, amount,offset, buffer)| 向一个大对象写数据。 |
|WRITEAPPEND(lob_loc IN OUT,amount, buffer)	|将数据从缓冲区写到大对象的末端。|
示例：
    DBMS_LOB.WRITEAPPEND (
      lob_loc IN OUT NOCOPY BLOB, 
      mount  ININTEGER, 
      buffer  INRAW); 
    
    DBMS_LOB.WRITEAPPEND (
    lob_loc IN OUT NOCOPY CLOB CHARACTER SET ANY_CS, 
    amount  ININTEGER, 
    buffer  INVARCHAR2 CHARACTER SET lob_loc%CHARSET);
    
    declare
    v_clob1 clob;
    begin
    v_clob1:=to_clob('123456');
    dbms_output.put_line(v_clob1);
    DBMS_LOB.WRITEAPPEND(v_clob1,3,'789');
    dbms_output.put_line(v_clob1);
    end;
    /

## 5.5	DBMS_JOB ##
DBMS_JOB 主要用于对在 JOB QUEUE 中的 JOB 做管理，该包已经被 DBMS_SCHEDULER 包所取代。特别是，如果你正在管理 JOB 以控制系统负载，那么你应该考虑通过收回用户在该包上的执行权限，以禁止 DBMS_JOB 包。

示例：

     declare
      jobno number;
      begin dbms_job.submit(
    job=>jobno, 
      what=>'proc_job(2);',
      next_date=>sysdate,
      interval=>'sysdate+1/1440'); 
      COMMIT;
      dbms_output.put_line(jobno);
       end;
       /

## 5.6	DBMS_ASSERT ##
这个包来判定输入值的属性。

示例：

    select dbms_assert.enquote_name('TBase') from dual;
## 5.7	DBMS_OUTPUT ##
DBMS_OUTPUT 用于向消息缓冲区发送消息（文本行的形式出现），或者从消息缓冲区中获取消息。

|存储过程/函数|	描述|
|--|--|
|DISABLE	|禁用发送和接收信息的能力。|
|ENABLE(buffer size)	|启用发送和接收信息的能力。|
|GET LINE(line OUT, status OUT)| 从消息缓冲区获取一行。 |
|GET LINES(lines OUT, numlines IN OUT)	|从消息缓冲区获取多行。|
|NEW LINE	|放置一个行末字符序列。|
|PUT(item)	|放置一个没有行末字符序列的部分行。|
|PUT LINE(item)	|放置一个有行末字符序列的完整行。|
|SERVEROUTPUT(stdout)	|将来自 PUT、PUT LINE 或 NEW_LINE 的信息引导到标准输出或信息缓冲区。|
示例：
    \set ECHO none
    SET client_min_messages = warning;
    SET DATESTYLE TO ISO;
    SET client_encoding = utf8;
    \pset null '<NULL>'
    \set ECHO all
    
    DROP FUNCTION dbms_output_test();
    DROP TABLE dbms_output_test;
    
    -- DBMS_OUTPUT.DISABLE [0]
    CREATE TABLE dbms_output_test (id serial,buff VARCHAR(20), status INTEGER);
    CREATE FUNCTION dbms_output_test() RETURNS VOID AS $$
    DECLARE
    	buff	VARCHAR(20);
    	stts	INTEGER;
    BEGIN
    	PERFORM DBMS_OUTPUT.PUT_LINE ('ORAFCE TEST 1');
    	SELECT INTO buff,stts line,status FROM DBMS_OUTPUT.GET_LINE();
    	INSERT INTO dbms_output_test(buff,status) VALUES (buff, stts);
    END;
    $$ LANGUAGE plpgsql;
    SELECT dbms_output_test();
    DROP TABLE dbms_output_test;
    DROP FUNCTION dbms_output_test();
    
    -- DBMS_OUTPUT.PUT_LINE [1]
    CREATE FUNCTION dbms_output_test() RETURNS VOID AS $$
    DECLARE
    	buff1	VARCHAR(20) := 'orafce';
    BEGIN
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    	PERFORM DBMS_OUTPUT.SERVEROUTPUT ('t');
    	PERFORM DBMS_OUTPUT.PUT_LINE ('ORAFCE');
    	PERFORM DBMS_OUTPUT.PUT_LINE (buff1);
    	PERFORM DBMS_OUTPUT.PUT ('ABC');
    	PERFORM DBMS_OUTPUT.PUT_LINE ('');
    END;
    $$ LANGUAGE plpgsql;
    SELECT dbms_output_test();
    DROP FUNCTION dbms_output_test();
    
    -- DBMS_OUTPUT.PUT_LINE [2]
    CREATE FUNCTION dbms_output_test() RETURNS VOID AS $$
    BEGIN
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    	PERFORM DBMS_OUTPUT.SERVEROUTPUT ('t');
    	PERFORM DBMS_OUTPUT.PUT_LINE ('ORAFCE');
    END;
    $$ LANGUAGE plpgsql;
    SELECT dbms_output_test();
    DROP FUNCTION dbms_output_test();
    
    -- DBMS_OUTPUT.PUT [1]
    CREATE FUNCTION dbms_output_test() RETURNS VOID AS $$
    DECLARE
    	buff1	VARCHAR(20) := 'ora';
    	buff2	VARCHAR(20) := 'f';
    	buff3	VARCHAR(20) := 'ce';
    BEGIN
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    	PERFORM DBMS_OUTPUT.SERVEROUTPUT ('t');
    	PERFORM DBMS_OUTPUT.PUT ('ORA');
    	PERFORM DBMS_OUTPUT.PUT ('F');
    	PERFORM DBMS_OUTPUT.PUT ('CE');
    	PERFORM DBMS_OUTPUT.PUT_LINE ('');
    	PERFORM DBMS_OUTPUT.PUT ('ABC');
    	PERFORM DBMS_OUTPUT.PUT_LINE ('');
    END;
    $$ LANGUAGE plpgsql;
    SELECT dbms_output_test();
    DROP FUNCTION dbms_output_test();
    
    -- DBMS_OUTPUT.PUT [2]
    CREATE FUNCTION dbms_output_test() RETURNS VOID AS $$
    BEGIN
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    	PERFORM DBMS_OUTPUT.SERVEROUTPUT ('t');
    	PERFORM DBMS_OUTPUT.PUT ('ORAFCE');
    	PERFORM DBMS_OUTPUT.PUT_LINE ('');
    END;
    $$ LANGUAGE plpgsql;
    SELECT dbms_output_test();
    DROP FUNCTION dbms_output_test();
    
    -- DBMS_OUTPUT.GET_LINE [1]
    CREATE TABLE dbms_output_test (id serial,buff VARCHAR(20), status INTEGER);
    CREATE FUNCTION dbms_output_test() RETURNS VOID AS $$
    DECLARE
    	buff	VARCHAR(20);
    	stts	INTEGER;
    BEGIN
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    	PERFORM DBMS_OUTPUT.SERVEROUTPUT ('f');
    	PERFORM DBMS_OUTPUT.PUT_LINE ('ORAFCE TEST 1');
    	PERFORM DBMS_OUTPUT.PUT_LINE ('ORAFCE TEST 2');
    	SELECT INTO buff,stts line,status FROM DBMS_OUTPUT.GET_LINE();
    	INSERT INTO dbms_output_test(buff,status) VALUES (buff, stts);
    	SELECT INTO buff,stts line,status FROM DBMS_OUTPUT.GET_LINE();
    	INSERT INTO dbms_output_test(buff,status) VALUES (buff, stts);
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    END;
    $$ LANGUAGE plpgsql;
    SELECT dbms_output_test();
    SELECT * FROM dbms_output_test order by buff;
    DROP TABLE dbms_output_test;
    DROP FUNCTION dbms_output_test();
    
    -- DBMS_OUTPUT.GET_LINE [2]
    CREATE TABLE dbms_output_test (id serial,buff VARCHAR(20), status INTEGER);
    CREATE FUNCTION dbms_output_test() RETURNS VOID AS $$
    DECLARE
    	buff	VARCHAR(20);
    	stts	INTEGER;
    BEGIN
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    	PERFORM DBMS_OUTPUT.SERVEROUTPUT ('f');
    	PERFORM DBMS_OUTPUT.PUT_LINE ('ORAFCE TEST 1');
    	PERFORM DBMS_OUTPUT.PUT_LINE ('ORAFCE TEST 2');
    	SELECT INTO buff,stts line,status FROM DBMS_OUTPUT.GET_LINE();
    	INSERT INTO dbms_output_test(buff,status) VALUES (buff, stts);
    	PERFORM DBMS_OUTPUT.PUT_LINE ('ORAFCE TEST 3');
    	SELECT INTO buff,stts line,status FROM DBMS_OUTPUT.GET_LINE();
    	INSERT INTO dbms_output_test(buff,status) VALUES (buff, stts);
    	SELECT INTO buff,stts line,status FROM DBMS_OUTPUT.GET_LINE();
    	INSERT INTO dbms_output_test(buff,status) VALUES (buff, stts);
    	SELECT INTO buff,stts line,status FROM DBMS_OUTPUT.GET_LINE();
    	INSERT INTO dbms_output_test(buff,status) VALUES (buff, stts);
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    END;
    $$ LANGUAGE plpgsql;
    SELECT dbms_output_test();
    DROP TABLE dbms_output_test;
    DROP FUNCTION dbms_output_test();
    
    -- DBMS_OUTPUT.GET_LINE [3]
    CREATE TABLE dbms_output_test (id serial,buff VARCHAR(20), status INTEGER);
    CREATE FUNCTION dbms_output_test() RETURNS VOID AS $$
    DECLARE
    	buff	VARCHAR(20);
    	stts	INTEGER;
    BEGIN
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    	PERFORM DBMS_OUTPUT.SERVEROUTPUT ('f');
    	PERFORM DBMS_OUTPUT.PUT_LINE ('ORAFCE TEST 1');
    	PERFORM DBMS_OUTPUT.PUT_LINE ('ORAFCE TEST 2');
    	SELECT INTO buff,stts line,status FROM DBMS_OUTPUT.GET_LINE();
    	INSERT INTO dbms_output_test(buff,status) VALUES (buff, stts);
    	PERFORM DBMS_OUTPUT.PUT ('ORA');
    	SELECT INTO buff,stts line,status FROM DBMS_OUTPUT.GET_LINE();
    	INSERT INTO dbms_output_test(buff,status) VALUES (buff, stts);
    	SELECT INTO buff,stts line,status FROM DBMS_OUTPUT.GET_LINE();
    	INSERT INTO dbms_output_test(buff,status) VALUES (buff, stts);
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    END;
    $$ LANGUAGE plpgsql;
    SELECT dbms_output_test();
    DROP TABLE dbms_output_test;
    DROP FUNCTION dbms_output_test();
    
    -- DBMS_OUTPUT.GET_LINE [4]
    CREATE TABLE dbms_output_test (id serial,buff VARCHAR(20), status INTEGER);
    CREATE FUNCTION dbms_output_test() RETURNS VOID AS $$
    DECLARE
    	buff	VARCHAR(20);
    	stts	INTEGER;
    BEGIN
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    	PERFORM DBMS_OUTPUT.SERVEROUTPUT ('f');
    	PERFORM DBMS_OUTPUT.PUT_LINE ('ORAFCE TEST 1');
    	PERFORM DBMS_OUTPUT.PUT_LINE ('ORAFCE TEST 2');
    	SELECT INTO buff,stts line,status FROM DBMS_OUTPUT.GET_LINE();
    	INSERT INTO dbms_output_test(buff,status) VALUES (buff, stts);
    	PERFORM DBMS_OUTPUT.NEW_LINE();
    	SELECT INTO buff,stts line,status FROM DBMS_OUTPUT.GET_LINE();
    	INSERT INTO dbms_output_test(buff,status) VALUES (buff, stts);
    	SELECT INTO buff,stts line,status FROM DBMS_OUTPUT.GET_LINE();
    	INSERT INTO dbms_output_test(buff,status) VALUES (buff, stts);
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    END;
    $$ LANGUAGE plpgsql;
    SELECT dbms_output_test();
    DROP TABLE dbms_output_test;
    DROP FUNCTION dbms_output_test();
    
    -- DBMS_OUTPUT.GET_LINE [5]
    CREATE TABLE dbms_output_test (id serial,buff VARCHAR(20), status INTEGER);
    CREATE FUNCTION dbms_output_test() RETURNS VOID AS $$
    DECLARE
    	buff	VARCHAR(20);
    	stts	INTEGER;
    BEGIN
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    	PERFORM DBMS_OUTPUT.SERVEROUTPUT ('f');
    	PERFORM DBMS_OUTPUT.PUT_LINE ('ORAFCE TEST 1
    ');
    	PERFORM DBMS_OUTPUT.PUT_LINE ('ORAFCE TEST 2');
    	SELECT INTO buff,stts line,status FROM DBMS_OUTPUT.GET_LINE();
    	INSERT INTO dbms_output_test(buff,status) VALUES (buff, stts);
    	SELECT INTO buff,stts line,status FROM DBMS_OUTPUT.GET_LINE();
    	INSERT INTO dbms_output_test(buff,status) VALUES (buff, stts);
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    END;
    $$ LANGUAGE plpgsql;
    SELECT dbms_output_test();
    DROP TABLE dbms_output_test;
    DROP FUNCTION dbms_output_test();
    
    -- DBMS_OUTPUT.GET_LINE [6]
    CREATE TABLE dbms_output_test (id serial,buff VARCHAR(20), status INTEGER);
    CREATE FUNCTION dbms_output_test() RETURNS VOID AS $$
    DECLARE
    	buff	VARCHAR(20);
    	stts	INTEGER;
    BEGIN
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    	PERFORM DBMS_OUTPUT.SERVEROUTPUT ('f');
    	PERFORM DBMS_OUTPUT.PUT_LINE ('ORA
    F
    CE');
    	SELECT INTO buff,stts line,status FROM DBMS_OUTPUT.GET_LINE();
    	INSERT INTO dbms_output_test(buff,status) VALUES (buff, stts);
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    END;
    $$ LANGUAGE plpgsql;
    SELECT dbms_output_test();
    DROP TABLE dbms_output_test;
    DROP FUNCTION dbms_output_test();
    
    -- DBMS_OUTPUT.GET_LINES [1]
    CREATE TABLE dbms_output_test (id serial,buff VARCHAR(20), status INTEGER);
    CREATE FUNCTION dbms_output_test() RETURNS VOID AS $$
    DECLARE
    	buff	VARCHAR(20);
    	buff1	VARCHAR(20);
    	buff2	VARCHAR(20);
    	buff3	VARCHAR(20);
    	stts	INTEGER := 10;
    BEGIN
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    	PERFORM DBMS_OUTPUT.SERVEROUTPUT ('f');
    	PERFORM DBMS_OUTPUT.PUT_LINE ('ORAFCE TEST 1');
    	PERFORM DBMS_OUTPUT.PUT_LINE ('ORAFCE TEST 2');
    	PERFORM DBMS_OUTPUT.PUT_LINE ('ORAFCE TEST 3');
    	SELECT INTO buff1,buff2,buff3,stts lines[1],lines[2],lines[3],numlines FROM DBMS_OUTPUT.GET_LINES(stts);
    	INSERT INTO dbms_output_test(buff,status) VALUES (buff1, stts);
    	INSERT INTO dbms_output_test(buff,status) VALUES (buff2, stts);
    	INSERT INTO dbms_output_test(buff,status) VALUES (buff3, stts);
    	SELECT INTO buff,stts lines[1],numlines FROM DBMS_OUTPUT.GET_LINES(stts);
    	INSERT INTO dbms_output_test(buff,status) VALUES (buff, stts);
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    END;
    $$ LANGUAGE plpgsql;
    SELECT dbms_output_test();
    DROP TABLE dbms_output_test;
    DROP FUNCTION dbms_output_test();
    
    -- DBMS_OUTPUT.GET_LINES [2]
    CREATE TABLE dbms_output_test (id serial,buff VARCHAR(20), status INTEGER);
    CREATE FUNCTION dbms_output_test() RETURNS VOID AS $$
    DECLARE
    	buff	VARCHAR(20);
    	buff1	VARCHAR(20);
    	buff2	VARCHAR(20);
    	stts	INTEGER := 2;
    BEGIN
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    	PERFORM DBMS_OUTPUT.SERVEROUTPUT ('f');
    	PERFORM DBMS_OUTPUT.PUT_LINE ('ORAFCE TEST 1');
    	PERFORM DBMS_OUTPUT.PUT_LINE ('ORAFCE TEST 2');
    	PERFORM DBMS_OUTPUT.PUT_LINE ('ORAFCE TEST 3');
    	SELECT INTO buff1,buff2,stts lines[1],lines[2],numlines FROM DBMS_OUTPUT.GET_LINES(stts);
    	INSERT INTO dbms_output_test(buff,status) VALUES (buff1, stts);
    	INSERT INTO dbms_output_test(buff,status) VALUES (buff2, stts);
    	SELECT INTO buff,stts lines[1],numlines FROM DBMS_OUTPUT.GET_LINES(stts);
    	INSERT INTO dbms_output_test(buff,status) VALUES (buff, stts);
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    END;
    $$ LANGUAGE plpgsql;
    SELECT dbms_output_test();
    DROP TABLE dbms_output_test;
    DROP FUNCTION dbms_output_test();
    
    -- DBMS_OUTPUT.GET_LINES [3]
    CREATE TABLE dbms_output_test (id serial,buff VARCHAR(20), status INTEGER);
    CREATE FUNCTION dbms_output_test() RETURNS VOID AS $$
    DECLARE
    	buff	VARCHAR(20);
    	stts	INTEGER := 1;
    BEGIN
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    	PERFORM DBMS_OUTPUT.SERVEROUTPUT ('f');
    	PERFORM DBMS_OUTPUT.PUT_LINE ('ORAFCE TEST 1');
    	PERFORM DBMS_OUTPUT.PUT_LINE ('ORAFCE TEST 2');
    	SELECT INTO buff,stts lines[1],numlines FROM DBMS_OUTPUT.GET_LINES(stts);
    	INSERT INTO dbms_output_test(buff,status) VALUES (buff, stts);
    	PERFORM DBMS_OUTPUT.PUT_LINE ('ORAFCE TEST 3');
    	SELECT INTO buff,stts lines[1],numlines FROM DBMS_OUTPUT.GET_LINES(stts);
    	INSERT INTO dbms_output_test(buff,status) VALUES (buff, stts);
    	SELECT INTO buff,stts lines[1],numlines FROM DBMS_OUTPUT.GET_LINES(stts);
    	INSERT INTO dbms_output_test(buff,status) VALUES (buff, stts);
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    END;
    $$ LANGUAGE plpgsql;
    SELECT dbms_output_test();
    DROP TABLE dbms_output_test;
    DROP FUNCTION dbms_output_test();
    
    -- DBMS_OUTPUT.GET_LINES [4]
    CREATE TABLE dbms_output_test (id serial,buff VARCHAR(20), status INTEGER);
    CREATE FUNCTION dbms_output_test() RETURNS VOID AS $$
    DECLARE
    	buff	VARCHAR(20);
    	stts	INTEGER := 1;
    BEGIN
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    	PERFORM DBMS_OUTPUT.SERVEROUTPUT ('f');
    	PERFORM DBMS_OUTPUT.PUT_LINE ('ORAFCE TEST 1');
    	PERFORM DBMS_OUTPUT.PUT_LINE ('ORAFCE TEST 2');
    	SELECT INTO buff,stts lines[1],numlines FROM DBMS_OUTPUT.GET_LINES(stts);
    	INSERT INTO dbms_output_test(buff,status) VALUES (buff, stts);
    	PERFORM DBMS_OUTPUT.PUT ('ORA');
    	SELECT INTO buff,stts lines[1],numlines FROM DBMS_OUTPUT.GET_LINES(stts);
    	INSERT INTO dbms_output_test(buff,status) VALUES (buff, stts);
    	SELECT INTO buff,stts lines[1],numlines FROM DBMS_OUTPUT.GET_LINES(stts);
    	INSERT INTO dbms_output_test(buff,status) VALUES (buff, stts);
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    END;
    $$ LANGUAGE plpgsql;
    SELECT dbms_output_test();
    DROP TABLE dbms_output_test;
    DROP FUNCTION dbms_output_test();
    
    -- DBMS_OUTPUT.GET_LINES [5]
    CREATE TABLE dbms_output_test (id serial,buff VARCHAR(20), status INTEGER);
    CREATE FUNCTION dbms_output_test() RETURNS VOID AS $$
    DECLARE
    	buff	VARCHAR(20);
    	stts	INTEGER := 1;
    BEGIN
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    	PERFORM DBMS_OUTPUT.SERVEROUTPUT ('f');
    	PERFORM DBMS_OUTPUT.PUT_LINE ('ORAFCE TEST 1');
    	PERFORM DBMS_OUTPUT.PUT_LINE ('ORAFCE TEST 2');
    	SELECT INTO buff,stts lines[1],numlines FROM DBMS_OUTPUT.GET_LINES(stts);
    	INSERT INTO dbms_output_test(buff,status) VALUES (buff, stts);
    	PERFORM DBMS_OUTPUT.NEW_LINE();
    	SELECT INTO buff,stts lines[1],numlines FROM DBMS_OUTPUT.GET_LINES(stts);
    	INSERT INTO dbms_output_test(buff,status) VALUES (buff, stts);
    	SELECT INTO buff,stts lines[1],numlines FROM DBMS_OUTPUT.GET_LINES(stts);
    	INSERT INTO dbms_output_test(buff,status) VALUES (buff, stts);
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    END;
    $$ LANGUAGE plpgsql;
    SELECT dbms_output_test();
    DROP TABLE dbms_output_test;
    DROP FUNCTION dbms_output_test();
    
    -- DBMS_OUTPUT.GET_LINES [6]
    CREATE TABLE dbms_output_test (id serial,buff VARCHAR(20), status INTEGER);
    CREATE FUNCTION dbms_output_test() RETURNS VOID AS $$
    DECLARE
    	buff	VARCHAR(20);
    	stts	INTEGER := 1;
    BEGIN
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    	PERFORM DBMS_OUTPUT.SERVEROUTPUT ('f');
    	PERFORM DBMS_OUTPUT.PUT_LINE ('ORA
    F
    CE');
    	SELECT INTO buff,stts lines[1],numlines FROM DBMS_OUTPUT.GET_LINES(stts);
    	INSERT INTO dbms_output_test(buff,status) VALUES (buff, stts);
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    END;
    $$ LANGUAGE plpgsql;
    SELECT dbms_output_test();
    DROP TABLE dbms_output_test;
    DROP FUNCTION dbms_output_test();
    
    -- DBMS_OUTPUT.NEW_LINE [1]
    CREATE TABLE dbms_output_test (id serial,buff VARCHAR(20), status INTEGER);
    CREATE FUNCTION dbms_output_test() RETURNS VOID AS $$
    DECLARE
    	buff1	VARCHAR(20);
    	buff2	VARCHAR(20);
    	stts	INTEGER := 10;
    BEGIN
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    	PERFORM DBMS_OUTPUT.SERVEROUTPUT ('f');
    	PERFORM DBMS_OUTPUT.PUT ('ORA');
    	PERFORM DBMS_OUTPUT.NEW_LINE();
    	PERFORM DBMS_OUTPUT.PUT ('FCE');
    	PERFORM DBMS_OUTPUT.NEW_LINE();
    	SELECT INTO buff1,buff2,stts lines[1],lines[2],numlines FROM DBMS_OUTPUT.GET_LINES(stts);
    	INSERT INTO dbms_output_test(buff,status) VALUES (buff1, stts);
    	INSERT INTO dbms_output_test(buff,status) VALUES (buff2, stts);
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    END;
    $$ LANGUAGE plpgsql;
    SELECT dbms_output_test();
    DROP TABLE dbms_output_test;
    DROP FUNCTION dbms_output_test();
    
    -- DBMS_OUTPUT.NEW_LINE [2]
    CREATE TABLE dbms_output_test (id serial,buff VARCHAR(3000), status INTEGER);
    CREATE FUNCTION dbms_output_test() RETURNS VOID AS $$
    DECLARE
    	buff1	VARCHAR(3000);
    	stts	INTEGER := 10;
    BEGIN
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    	PERFORM DBMS_OUTPUT.SERVEROUTPUT ('f');
    	PERFORM DBMS_OUTPUT.ENABLE(2000);
    	FOR j IN 1..1999 LOOP
    		PERFORM DBMS_OUTPUT.PUT ('A');
    	END LOOP;
    	PERFORM DBMS_OUTPUT.NEW_LINE();
    	SELECT INTO buff1,stts lines[1],numlines FROM DBMS_OUTPUT.GET_LINES(stts);
    	INSERT INTO dbms_output_test(buff,status) VALUES (buff1, stts);
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    END;
    $$ LANGUAGE plpgsql;
    SELECT dbms_output_test();
    DROP TABLE dbms_output_test;
    DROP FUNCTION dbms_output_test();
    
    -- DBMS_OUTPUT.DISABLE [1]
    CREATE TABLE dbms_output_test (id serial,buff VARCHAR(20), status INTEGER);
    CREATE FUNCTION dbms_output_test() RETURNS VOID AS $$
    DECLARE
    	buff	VARCHAR(20);
    	stts	INTEGER;
    BEGIN
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    	PERFORM DBMS_OUTPUT.SERVEROUTPUT ('f');
    	PERFORM DBMS_OUTPUT.PUT_LINE ('ORAFCE TEST 1');
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    	SELECT INTO buff,stts line,status FROM DBMS_OUTPUT.GET_LINE();
    	INSERT INTO dbms_output_test(buff,status) VALUES (buff, stts);
    
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.PUT_LINE ('ORAFCE TEST 2');
    	PERFORM DBMS_OUTPUT.ENABLE();
    	SELECT INTO buff,stts line,status FROM DBMS_OUTPUT.GET_LINE();
    	INSERT INTO dbms_output_test(buff,status) VALUES (buff, stts);
    	
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    	PERFORM DBMS_OUTPUT.PUT_LINE ('ORAFCE TEST 3');
    	PERFORM DBMS_OUTPUT.DISABLE();
    	SELECT INTO buff,stts line,status FROM DBMS_OUTPUT.GET_LINE();
    	INSERT INTO dbms_output_test(buff,status) VALUES (buff, stts);
    	PERFORM DBMS_OUTPUT.ENABLE();
    
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.PUT ('ORAFCE TEST 4');
    	PERFORM DBMS_OUTPUT.ENABLE();
    	PERFORM DBMS_OUTPUT.NEW_LINE();
    	SELECT INTO buff,stts line,status FROM DBMS_OUTPUT.GET_LINE();
    	INSERT INTO dbms_output_test(buff,status) VALUES (buff, stts);
    
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    	PERFORM DBMS_OUTPUT.PUT ('ORAFCE TEST 5');
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.NEW_LINE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    	SELECT INTO buff,stts line,status FROM DBMS_OUTPUT.GET_LINE();
    	INSERT INTO dbms_output_test(buff,status) VALUES (buff, stts);
    
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    END;
    $$ LANGUAGE plpgsql;
    SELECT dbms_output_test();
    DROP TABLE dbms_output_test;
    DROP FUNCTION dbms_output_test();
    
    -- DBMS_OUTPUT.DISABLE [2]
    CREATE TABLE dbms_output_test (id serial,buff VARCHAR(20), status INTEGER);
    CREATE FUNCTION dbms_output_test() RETURNS VOID AS $$
    DECLARE
    	buff	VARCHAR(20);
    	stts	INTEGER := 10;
    BEGIN
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    	PERFORM DBMS_OUTPUT.SERVEROUTPUT ('f');
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.PUT_LINE ('ORAFCE TEST 1');
    	SELECT INTO buff,stts lines[1],numlines FROM DBMS_OUTPUT.GET_LINES(stts);
    	INSERT INTO dbms_output_test(buff,status) VALUES (buff, stts);
    	PERFORM DBMS_OUTPUT.ENABLE();
    END;
    $$ LANGUAGE plpgsql;
    SELECT dbms_output_test();
    DROP TABLE dbms_output_test;
    DROP FUNCTION dbms_output_test();
    
    -- DBMS_OUTPUT.ENABLE [1]
    CREATE TABLE dbms_output_test (id serial,buff VARCHAR(20), status INTEGER);
    CREATE FUNCTION dbms_output_test() RETURNS VOID AS $$
    DECLARE
    	buff	VARCHAR(20);
    	status	INTEGER;
    	num		INTEGER := 2000;
    BEGIN
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    	PERFORM DBMS_OUTPUT.SERVEROUTPUT ('t');
    	PERFORM DBMS_OUTPUT.ENABLE(2000);
    	PERFORM DBMS_OUTPUT.PUT ('ORAFCE TEST 1');
    	PERFORM DBMS_OUTPUT.NEW_LINE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    END;
    $$ LANGUAGE plpgsql;
    SELECT dbms_output_test();
    DROP TABLE dbms_output_test;
    DROP FUNCTION dbms_output_test();
    
    -- DBMS_OUTPUT.ENABLE [2]
    CREATE TABLE dbms_output_test (id serial,buff VARCHAR(20), status INTEGER);
    CREATE FUNCTION dbms_output_test() RETURNS VOID AS $$
    DECLARE
    	buff	VARCHAR(20);
    	stts	INTEGER;
    BEGIN
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    	PERFORM DBMS_OUTPUT.SERVEROUTPUT ('f');
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    	PERFORM DBMS_OUTPUT.PUT_LINE ('ORAFCE TEST 1');
    	SELECT INTO buff,stts line,status FROM DBMS_OUTPUT.GET_LINE();
    	INSERT INTO dbms_output_test(buff,status) VALUES (buff, stts);
    	PERFORM DBMS_OUTPUT.PUT ('ORAFCE TEST 2');
    	PERFORM DBMS_OUTPUT.NEW_LINE();
    	SELECT INTO buff,stts line,status FROM DBMS_OUTPUT.GET_LINE();
    	INSERT INTO dbms_output_test(buff,status) VALUES (buff, stts);
    	PERFORM DBMS_OUTPUT.ENABLE();
    END;
    $$ LANGUAGE plpgsql;
    SELECT dbms_output_test();
    DROP TABLE dbms_output_test;
    DROP FUNCTION dbms_output_test();
    
    -- DBMS_OUTPUT.ENABLE [3]
    CREATE TABLE dbms_output_test (id serial,buff VARCHAR(20), status INTEGER);
    CREATE FUNCTION dbms_output_test() RETURNS VOID AS $$
    DECLARE
    	buff	VARCHAR(20);
    	stts	INTEGER := 10;
    BEGIN
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    	PERFORM DBMS_OUTPUT.SERVEROUTPUT ('f');
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    	PERFORM DBMS_OUTPUT.PUT_LINE ('ORAFCE TEST 1');
    	SELECT INTO buff,stts lines[1],numlines FROM DBMS_OUTPUT.GET_LINES(stts);
    	INSERT INTO dbms_output_test(buff,status) VALUES (buff, stts);
    
    END;
    $$ LANGUAGE plpgsql;
    SELECT dbms_output_test();
    DROP TABLE dbms_output_test;
    DROP FUNCTION dbms_output_test();
    
    -- DBMS_OUTPUT.ENABLE [4]
    CREATE FUNCTION dbms_output_test() RETURNS VOID AS $$
    BEGIN
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    	PERFORM DBMS_OUTPUT.SERVEROUTPUT ('t');
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    	FOR j IN 1..2000 LOOP
    		PERFORM DBMS_OUTPUT.PUT ('A');
    	END LOOP;
    	PERFORM DBMS_OUTPUT.NEW_LINE();
    END;
    $$ LANGUAGE plpgsql;
    SELECT dbms_output_test();
    DROP FUNCTION dbms_output_test();
    
    -- DBMS_OUTPUT.ENABLE [5]
    CREATE TABLE dbms_output_test (id serial,buff VARCHAR(20), status INTEGER);
    CREATE FUNCTION dbms_output_test() RETURNS VOID AS $$
    DECLARE
    	buff	VARCHAR(20);
    	stts	INTEGER;
    BEGIN
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    	PERFORM DBMS_OUTPUT.SERVEROUTPUT ('f');
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE(NULL);
    	PERFORM DBMS_OUTPUT.PUT_LINE ('ORAFCE TEST 1');
    	SELECT INTO buff,stts line,status FROM DBMS_OUTPUT.GET_LINE();
    	INSERT INTO dbms_output_test(buff,status) VALUES (buff, stts);
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    END;
    $$ LANGUAGE plpgsql;
    SELECT dbms_output_test();
    DROP TABLE dbms_output_test;
    DROP FUNCTION dbms_output_test();
    
    -- DBMS_OUTPUT.ENABLE [6]
    CREATE TABLE dbms_output_test (id serial,buff VARCHAR(20), status INTEGER);
    CREATE FUNCTION dbms_output_test() RETURNS VOID AS $$
    DECLARE
    	buff	VARCHAR(20);
    	stts	INTEGER;
    BEGIN
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    	PERFORM DBMS_OUTPUT.SERVEROUTPUT ('f');
    	PERFORM DBMS_OUTPUT.PUT_LINE ('ORAFCE TEST 1');
    	PERFORM DBMS_OUTPUT.ENABLE();
    	SELECT INTO buff,stts line,status FROM DBMS_OUTPUT.GET_LINE();
    	INSERT INTO dbms_output_test(buff,status) VALUES (buff, stts);
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    END;
    $$ LANGUAGE plpgsql;
    SELECT dbms_output_test();
    DROP TABLE dbms_output_test;
    DROP FUNCTION dbms_output_test();
    
    -- SERVEROUTPUT [1]
    CREATE FUNCTION dbms_output_test() RETURNS VOID AS $$
    BEGIN
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    	PERFORM DBMS_OUTPUT.SERVEROUTPUT ('f');
    	PERFORM DBMS_OUTPUT.PUT_LINE ('ORAFCE TEST 1');
    END;
    $$ LANGUAGE plpgsql;
    SELECT dbms_output_test();
    DROP FUNCTION dbms_output_test();
    
    CREATE FUNCTION dbms_output_test() RETURNS VOID AS $$
    BEGIn
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    	PERFORM DBMS_OUTPUT.SERVEROUTPUT ('t');
    	PERFORM DBMS_OUTPUT.PUT_LINE ('ORAFCE TEST 2');
    END;
    $$ LANGUAGE plpgsql;
    SELECT dbms_output_test();
    DROP FUNCTION dbms_output_test();
    
    -- SERVEROUTPUT [2]
    CREATE FUNCTION dbms_output_test() RETURNS VOID AS $$
    BEGIN
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    	PERFORM DBMS_OUTPUT.SERVEROUTPUT ('f');
    	PERFORM DBMS_OUTPUT.PUT ('ORAFCE TEST 1');
    	PERFORM DBMS_OUTPUT.NEW_LINE();
    END;
    $$ LANGUAGE plpgsql;
    SELECT dbms_output_test();
    DROP FUNCTION dbms_output_test();
    
    CREATE FUNCTION dbms_output_test() RETURNS VOID AS $$
    BEGIN
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    	PERFORM DBMS_OUTPUT.SERVEROUTPUT ('t');
    	PERFORM DBMS_OUTPUT.PUT ('ORAFCE TEST 2');
    	PERFORM DBMS_OUTPUT.NEW_LINE();
    END;
    $$ LANGUAGE plpgsql;
    SELECT dbms_output_test();
    DROP FUNCTION dbms_output_test();
    
    -- SERVEROUTPUT [3]
    CREATE FUNCTION dbms_output_test() RETURNS VOID AS $$
    BEGIN
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    	PERFORM DBMS_OUTPUT.SERVEROUTPUT ('f');
    	PERFORM DBMS_OUTPUT.DISABLE();
    END;
    $$ LANGUAGE plpgsql;
    SELECT dbms_output_test();
    DROP FUNCTION dbms_output_test();
    
    CREATE FUNCTION dbms_output_test() RETURNS VOID AS $$
    BEGIN
    	PERFORM DBMS_OUTPUT.DISABLE();
    	PERFORM DBMS_OUTPUT.ENABLE();
    	PERFORM DBMS_OUTPUT.SERVEROUTPUT ('t');
    	PERFORM DBMS_OUTPUT.PUT_LINE ('ORAFCE TEST 1');
    END;
    $$ LANGUAGE plpgsql;
    SELECT dbms_output_test();
    DROP FUNCTION dbms_output_test();

## 5.8	DBMS_PIPE ##
DBMS_PIPE 包用于在同一实例的不同会话之间进行通信。注意，如果用户要执行 DBMS_PIPE 包中的过程和函数，则必须要为用户授权。

DBMS_PIPE 包含以下接口：

|接口|	描述|
|--|--|
|*CREATE_PIPE	|用于建立公用管道或私有管道。如果将参数 private 设置为 TRUE，则建立私有管道；如果设置为 FALSE，则建立公用管道。|
|*PACK_MESSAGE| 用于将消息写入到本地消息缓冲区，包含类型 number、bytea、date、string、timestamp、record。 |
|*SEND_MESSAGE	|用于将本地消息缓冲区中的内容发送到管道。|
|*RECEIVE_MESSAGE| 用于接收管道消息。 |
|NEXT_ITEM_TYPE	|用于确定本地消息缓冲区下一项的数据类型。如果该函数返回0，则表示管道没有任何消息。|
|*UNPACK_MESSAGE	|用于将消息缓冲区的内容写入到变量中。|
|*REMOVE_PIPE| 用于删除已经建立的管道。 |
|PUGER	|用于清除管道中的内容。|
|RESET_BUFFER| 用于复位管道缓冲区。 |
|UNIQUE_SESSION_NAME| 用于为特定会话返回惟一的名称，并且名称的最长度为 30 字节。 |
示例：

    create or replace procedure dbmspipe_crtpipe_pro(in_cno int) as
    declare
    v_no int;
    v_bigint bigint;
    v_bytea bytea;
    v_date date;
    v_int int;
    v_num numeric;
    v_text text;
    v_tmptz timestamp with time zone;
    begin
      select c,c_bigint,c_bytea,c_date,c_int,c_num,c_text,c_tmptz
      from dbmspipe_tbl
      where c=in_cno
      into v_no,v_bigint,v_bytea,v_date,v_int,v_num,v_text,v_tmptz;
      perform dbms_pipe.create_pipe('bigint_pipe1'||v_no);
      perform dbms_pipe.pack_message(v_bigint);
      perform dbms_pipe.send_message('bigint_pipe1'||v_no);
      perform dbms_pipe.create_pipe('bigint_pipe2'||v_no,50);
      perform dbms_pipe.pack_message(v_bigint);
      perform dbms_pipe.send_message('bigint_pipe2'||v_no);
      perform dbms_pipe.create_pipe('bigint_pipe3'||v_no,100,true);
      perform dbms_pipe.pack_message(v_bigint);
      perform dbms_pipe.send_message('bigint_pipe3'||v_no);
      perform dbms_pipe.create_pipe('bigint_pipe4'||v_no,200,false);
      perform dbms_pipe.pack_message(v_bigint);
      perform dbms_pipe.send_message('bigint_pipe4'||v_no);
    
      perform dbms_pipe.create_pipe('bytea_pipe1'||v_no);
      perform dbms_pipe.pack_message(v_bytea);
      perform dbms_pipe.send_message('bytea_pipe1'||v_no);
      perform dbms_pipe.create_pipe('bytea_pipe2'||v_no,50);
      perform dbms_pipe.pack_message(v_bytea);
      perform dbms_pipe.send_message('bytea_pipe2'||v_no);
      perform dbms_pipe.create_pipe('bytea_pipe3'||v_no,100,true);
      perform dbms_pipe.pack_message(v_bytea);
      perform dbms_pipe.send_message('bytea_pipe3'||v_no);
      perform dbms_pipe.create_pipe('bytea_pipe4'||v_no,200,false);
      perform dbms_pipe.pack_message(v_bytea);
      perform dbms_pipe.send_message('bytea_pipe4'||v_no);
    
      perform dbms_pipe.create_pipe('date_pipe1'||v_no);
      perform dbms_pipe.pack_message(v_date);
      perform dbms_pipe.send_message('date_pipe1'||v_no);
      perform dbms_pipe.create_pipe('date_pipe2'||v_no,50);
      perform dbms_pipe.pack_message(v_date);
      perform dbms_pipe.send_message('date_pipe2'||v_no);
      perform dbms_pipe.create_pipe('date_pipe3'||v_no,100,true);
      perform dbms_pipe.pack_message(v_date);
      perform dbms_pipe.send_message('date_pipe3'||v_no);
      perform dbms_pipe.create_pipe('date_pipe4'||v_no,200,false);
      perform dbms_pipe.pack_message(v_date);
      perform dbms_pipe.send_message('date_pipe4'||v_no);
    
      perform dbms_pipe.create_pipe('int_pipe1'||v_no);
      perform dbms_pipe.pack_message(v_int);
      perform dbms_pipe.send_message('int_pipe1'||v_no);
      perform dbms_pipe.create_pipe('int_pipe2'||v_no,50);
      perform dbms_pipe.pack_message(v_int);
      perform dbms_pipe.send_message('int_pipe2'||v_no);
      perform dbms_pipe.create_pipe('int_pipe3'||v_no,100,true);
      perform dbms_pipe.pack_message(v_int);
      perform dbms_pipe.send_message('int_pipe3'||v_no);
      perform dbms_pipe.create_pipe('int_pipe4'||v_no,200,false);
      perform dbms_pipe.pack_message(v_int);
      perform dbms_pipe.send_message('int_pipe4'||v_no);
    
      perform dbms_pipe.create_pipe('num_pipe1'||v_no);
      perform dbms_pipe.pack_message(v_num);
      perform dbms_pipe.send_message('num_pipe1'||v_no);
      perform dbms_pipe.create_pipe('num_pipe2'||v_no,50);
      perform dbms_pipe.pack_message(v_num);
      perform dbms_pipe.send_message('num_pipe2'||v_no);
      perform dbms_pipe.create_pipe('num_pipe3'||v_no,100,true);
      perform dbms_pipe.pack_message(v_num);
      perform dbms_pipe.send_message('num_pipe3'||v_no);
      perform dbms_pipe.create_pipe('num_pipe4'||v_no,200,false);
      perform dbms_pipe.pack_message(v_num);
      perform dbms_pipe.send_message('num_pipe4'||v_no);
    
      perform dbms_pipe.create_pipe('text_pipe1'||v_no);
      perform dbms_pipe.pack_message(v_text);
      perform dbms_pipe.send_message('text_pipe1'||v_no);
      perform dbms_pipe.create_pipe('text_pipe2'||v_no,50);
      perform dbms_pipe.pack_message(v_text);
      perform dbms_pipe.send_message('text_pipe2'||v_no);
      perform dbms_pipe.create_pipe('text_pipe3'||v_no,100,true);
      perform dbms_pipe.pack_message(v_text);
      perform dbms_pipe.send_message('text_pipe3'||v_no);
      perform dbms_pipe.create_pipe('text_pipe4'||v_no,200,false);
      perform dbms_pipe.pack_message(v_text);
      perform dbms_pipe.send_message('text_pipe4'||v_no);
    
      perform dbms_pipe.create_pipe('tmptz_pipe1'||v_no);
      perform dbms_pipe.pack_message(v_tmptz);
      perform dbms_pipe.send_message('tmptz_pipe1'||v_no);
      perform dbms_pipe.create_pipe('tmptz_pipe2'||v_no,50);
      perform dbms_pipe.pack_message(v_tmptz);
      perform dbms_pipe.send_message('tmptz_pipe2'||v_no);
      perform dbms_pipe.create_pipe('tmptz_pipe3'||v_no,100,true);
      perform dbms_pipe.pack_message(v_tmptz);
      perform dbms_pipe.send_message('tmptz_pipe3'||v_no);
      perform dbms_pipe.create_pipe('tmptz_pipe4'||v_no,200,false);
      perform dbms_pipe.pack_message(v_tmptz);
      perform dbms_pipe.send_message('tmptz_pipe4'||v_no);
    end;
    /
    
    --创建接收pipe message，打印message子存储过程
    create or replace procedure rec_subpro(in_pipename varchar) as
    declare
    v_num numeric;
    v_bytea bytea;
    v_date date;
    v_str varchar;
    v_tmptz timestamp with time zone;
    begin
      perform dbms_output.disable();
      perform dbms_output.enable();
      perform dbms_output.serveroutput ('t');
      perform dbms_pipe.receive_message(in_pipename);
      if in_pipename like '%int%' or in_pipename like 'num' then
    v_num := dbms_pipe.unpack_message_number();
    perform dbms_output.put_line(in_pipename || ' message: '||v_num);
      elsif in_pipename like '%bytea%' then
    v_bytea := dbms_pipe.unpack_message_bytea();
    perform dbms_output.put_line(in_pipename || ' message: '||v_bytea);
      elsif in_pipename like '%date%' then
    v_date := dbms_pipe.unpack_message_date();
    perform dbms_output.put_line(in_pipename || ' message: '||v_date::text);
      elsif in_pipename like '%text%' then
    v_str := dbms_pipe.unpack_message_text();
    perform dbms_output.put_line(in_pipename || ' message: '||v_str);
      elsif in_pipename like '%tmptz%' then
    v_tmptz := dbms_pipe.unpack_message_timestamp();
    perform dbms_output.put_line(in_pipename || ' message: '||v_tmptz::text);
      end if;
      perform dbms_pipe.remove_pipe(in_pipename);
    end;
    /
    --unpack_message_*测试：接收pipe中各种数据类型的message（record除外），接收后remove_pipe，打印出message
    create or replace procedure dbmspipe_rec_pro(in_cno int) as
    begin
      call rec_subpro('bigint_pipe1'||in_cno);
      call rec_subpro('bigint_pipe2'||in_cno);
      call rec_subpro('bigint_pipe3'||in_cno);
      call rec_subpro('bigint_pipe4'||in_cno);
    
      call rec_subpro('bytea_pipe1'||in_cno);
      call rec_subpro('bytea_pipe2'||in_cno);
      call rec_subpro('bytea_pipe3'||in_cno);
      call rec_subpro('bytea_pipe4'||in_cno);
    
      call rec_subpro('date_pipe1'||in_cno);
      call rec_subpro('date_pipe2'||in_cno);
      call rec_subpro('date_pipe3'||in_cno);
      call rec_subpro('date_pipe4'||in_cno);
    
      call rec_subpro('int_pipe1'||in_cno);
      call rec_subpro('int_pipe2'||in_cno);
      call rec_subpro('int_pipe3'||in_cno);
      call rec_subpro('int_pipe4'||in_cno);
    
      call rec_subpro('num_pipe1'||in_cno);
      call rec_subpro('num_pipe2'||in_cno);
      call rec_subpro('num_pipe3'||in_cno);
      call rec_subpro('num_pipe4'||in_cno);
    
      call rec_subpro('text_pipe1'||in_cno);
      call rec_subpro('text_pipe2'||in_cno);
      call rec_subpro('text_pipe3'||in_cno);
      call rec_subpro('text_pipe4'||in_cno);
    
      call rec_subpro('tmptz_pipe1'||in_cno);
      call rec_subpro('tmptz_pipe2'||in_cno);
      call rec_subpro('tmptz_pipe3'||in_cno);
      call rec_subpro('tmptz_pipe4'||in_cno);
    end;
    /
    --sessionA:
    call dbmspipe_crtpipe_pro(1);
    --sessionB:
    call dbmspipe_rec_pro(1);
    --sessionA:
    call dbmspipe_crtpipe_pro(2);
    --sessionB:
    call dbmspipe_rec_pro(2);
    --sessionA:
    call dbmspipe_crtpipe_pro(3);
    --sessionB:
    call dbmspipe_rec_pro(3);
    --sessionA:
    call dbmspipe_crtpipe_pro(4);
    --sessionB:
    call dbmspipe_rec_pro(4);
    --sessionA:
    call dbmspipe_crtpipe_pro(5);
    --sessionB:
    call dbmspipe_rec_pro(5);

## 5.9	DBMS_UTILITY ##
DBMS_UTILITY 包含一个接口： FORMAT_CALL_STACK，该函数格式化当前的调用堆栈。该函数可以在任何存储过程或触发器上使用，以访问调用栈。这对于调试是很有用的。

示例：

    create or replace function dbms_uti_func() returns text as
    declare
    v_str1 text;
    v_str2 text;
    v_str3 text;
    v_str4 text;
    begin
      v_str1 := dbms_utility.format_call_stack();
      select regexp_replace(v_str1,'[ 0-9a-fA-F]{4}[0-9a-fA-F]{4}','   0','g') into v_str1;
      select regexp_replace(v_str1,'[45()]','','g') into v_str1;
      v_str2 := dbms_utility.format_call_stack('o');
      select regexp_replace(v_str2,'[ 0-9a-fA-F]{4}[0-9a-fA-F]{4}','   0','g') into v_str2;
      select regexp_replace(v_str2,'[45()]','','g') into v_str2;
      v_str3 := dbms_utility.format_call_stack('p');
      select regexp_replace(v_str3,'[ 0-9a-fA-F]{4}[0-9a-fA-F]{4}','   0','g') into v_str3;
      select regexp_replace(v_str3,'[45()]','','g') into v_str3;
      v_str4 := dbms_utility.format_call_stack('s');
      select regexp_replace(v_str4,'[ 0-9a-fA-F]{4}[0-9a-fA-F]{4}','   0','g') into v_str4;
      select regexp_replace(v_str4,'[45()]','','g') into v_str4;
      return 'v_str1:
    '||v_str1 || '
    v_str2:
    '|| v_str2|| '
    v_str3:
    '|| v_str3|| '
    v_str4:
    '|| v_str4;
    end;
    /
    select dbms_uti_func();

## 5.10	UTL_FILE ##
UTL_FILE 包提供文本文件输入和输出功能。

UTL_FILE 包含以下接口：

|接口	|描述|
|--|--|
|*FOPEN	| 用于打开文件。 |
|IS_OPEN| 用于确定文件是否已经被打开。 |
|FCLOSE| 用于关闭已经打开的文件。 |
|FCLOSE_ALL	| 该过程用于关闭当前打开的所有文件。 |
|GET_LINE	|用于从已经打开的文件中读取行内容，行内容会被读取到输出缓冲区。|
|GET_NEXTLINE| 用于从已经打开的文件中读取下一条行内容。 |
|*PUT		|用于将缓冲区内容写入到文件中。当使用PUT过程的时候，文件必须以写方式打开，在写入缓冲区之后，如果要结束行，那么可以使用NEW_LINE过程。|
|NEW_LINE	|该过程用于为文件增加行终止符。|
|*PUT_LINE|	该过程用于将文本缓冲区内容写入到文件中。当使用该过程为文件追加内容时，会自动在文件的尾部追加行终止符。|
|FFLUSH|	用于将数据强制性写入到文件中，正常情况下，当给文件写入数据的时候，数据会被暂时的放到缓存中。过程FFLUSH用于强制将数据写入到文件中。|
|FREMOVE	|用于删除磁盘文件。|
|*FCOPY		|用于将源文件的全部或者部分内容复制到目标文件中。|
|*FRENAME	| 该过程用于修改已经存在的文件名字，其作用于UNIX的MV命令完全相同，在修改文件名字的时候，通过指定overwrite参数可以覆盖已经存在的文件。 |
|FGETATTR	| 读取磁盘上的文件并返回文件的属性。 |
|FRENAME	| 将一个存在的文件重命名。 |
|PUTF	|写入格式化的内容到文件中。|
示例：

    create or replace procedure utlfile_open_prowa() as
    declare
    v_count int;
    v_fileint integer;
    begin
      --open_node=w
      v_fileint := utl_file.fopen('/data1/tbasev5_autotest/tbaseTest/TbaseV5/pro_package/data/utl_file_dir','file_w.txt','w');
      perform utl_file.put_line(v_fileint,'write file test.');
      if utl_file.is_open(v_fileint) then
    perform utl_file.fclose(v_fileint);
      end if;
      v_fileint := utl_file.fopen('/data1/tbasev5_autotest/tbaseTest/TbaseV5/pro_package/data/utl_file_dir','file_w.txt','w',50);
      perform utl_file.new_line(v_fileint);
      perform utl_file.put_line(v_fileint,'一二三四五六七八九十');
      if utl_file.is_open(v_fileint) then
    perform utl_file.fclose(v_fileint);
      end if;
      v_fileint := utl_file.fopen('/data1/tbasev5_autotest/tbaseTest/TbaseV5/pro_package/data/utl_file_dir','file_w.txt','w',18,'SQL_ASCII');
      perform utl_file.new_line(v_fileint);
      perform utl_file.put_line(v_fileint,'nice to meet you');
      if utl_file.is_open(v_fileint) then
    perform utl_file.fclose(v_fileint);
      end if;
      v_fileint := utl_file.fopen('/data1/tbasev5_autotest/tbaseTest/TbaseV5/pro_package/data/utl_file_dir','file_w.txt','w',31,'UTF-8');
      perform utl_file.new_line(v_fileint);
      perform utl_file.put_line(v_fileint,'abcdefg hijklmn opq rst uvw xyz');
      if utl_file.is_open(v_fileint) then
    perform utl_file.fclose(v_fileint);
      end if;
      v_fileint := utl_file.fopen('/data1/tbasev5_autotest/tbaseTest/TbaseV5/pro_package/data/utl_file_dir','file_w.txt','w',88,'GBK');
      perform utl_file.new_line(v_fileint);
      perform utl_file.put_line(v_fileint,'hello');
      if utl_file.is_open(v_fileint) then
    perform utl_file.fclose(v_fileint);
      end if;
      --open_mode=a
      v_fileint := utl_file.fopen('/data1/tbasev5_autotest/tbaseTest/TbaseV5/pro_package/data/utl_file_dir','file_w.txt','a');
      perform utl_file.put_line(v_fileint,'write file test.');
      if utl_file.is_open(v_fileint) then
    perform utl_file.fclose(v_fileint);
      end if;
      v_fileint := utl_file.fopen('/data1/tbasev5_autotest/tbaseTest/TbaseV5/pro_package/data/utl_file_dir','file_w.txt','a',50);
      perform utl_file.new_line(v_fileint);
      perform utl_file.put_line(v_fileint,'一二三四五六七八九十');
      if utl_file.is_open(v_fileint) then
    perform utl_file.fclose(v_fileint);
      end if;
      v_fileint := utl_file.fopen('/data1/tbasev5_autotest/tbaseTest/TbaseV5/pro_package/data/utl_file_dir','file_w.txt','a',18,'SQL_ASCII');
      perform utl_file.new_line(v_fileint);
      perform utl_file.put_line(v_fileint,'nice to meet you');
      if utl_file.is_open(v_fileint) then
    perform utl_file.fclose(v_fileint);
      end if;
      v_fileint := utl_file.fopen('/data1/tbasev5_autotest/tbaseTest/TbaseV5/pro_package/data/utl_file_dir','file_w.txt','a',31,'UTF-8');
      perform utl_file.new_line(v_fileint);
      perform utl_file.put_line(v_fileint,'abcdefg hijklmn opq rst uvw xyz');
      if utl_file.is_open(v_fileint) then
    perform utl_file.fclose(v_fileint);
      end if;
      v_fileint := utl_file.fopen('/data1/tbasev5_autotest/tbaseTest/TbaseV5/pro_package/data/utl_file_dir','file_w.txt','a',88,'GBK');
      perform utl_file.new_line(v_fileint);
      perform utl_file.put_line(v_fileint,'hello');
      if utl_file.is_open(v_fileint) then
    perform utl_file.fclose(v_fileint);
      end if;
    exception
      when others then
    raise notice 'EXP: something wrong.';
    end;
    /
    call utlfile_open_prowa();
