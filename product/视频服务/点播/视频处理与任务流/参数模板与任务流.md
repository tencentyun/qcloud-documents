视频处理操作存在如下几个特点：

- **输入参数众多**：单项视频处理操作可能存在很多输入参数，如果每一次视频处理操作都需要携带所有参数，则接口调用必然十分复杂；例如转码操作，存在数十个控制参数。
- **处理种类多样**：同一个视频可能存在多种不同的处理方式，如果每一种操作都需要独立的接口来调用，则开发者的接入过程必然十分复杂；例如对同一个视频可能需要进行标清、高清、超清三路转码，并进行雪碧图截图。
- **处理流程复杂**：针对同一个视频的不同处理操作之间可能存在依赖关系，如果仅提供原子化的视频处理接口，则开发者需要依赖视频处理回调来进行逻辑判断；例如：依照原始视频的码率决定转码出几路，再如依照鉴黄结果决定是否需要进行转码。

[参数模板](#.E5.8F.82.E6.95.B0.E6.A8.A1.E6.9D.BF)与[任务流](#.E4.BB.BB.E5.8A.A1.E6.B5.81)，正是点播系统针对视频处理以上几个问题给出的解决方案。其中，参数模板解决了第一个问题，任务流则解决了后两个问题。

参数、模板、任务流三者的关系如下图所示：
![参数-模板-任务流](//mc.qcloudimg.com/static/img/06cc3e175e8fce4ae44b68c6fb3173c4/image.png)

## 参数模板

所谓参数模板，是将一种视频处理的众多参数封装到一个模板中（参数容器），同时为该模板赋予一个ID。在视频处理过程中，可以通过一个模板ID代表一组视频处理参数。

点播系统既提供了预置参数模板，同时还允许开发者自定义参数模板，参见：

- [转码模板](/document/product/266/11701#.E8.BD.AC.E7.A0.81.E6.A8.A1.E6.9D.BF)
- [转封装模板](/document/product/266/11701#.E8.A7.86.E9.A2.91.E8.BD.AC.E5.B0.81.E8.A3.85)
- [水印模板](/document/product/266/11701#.E6.B0.B4.E5.8D.B0.E6.A8.A1.E6.9D.BF)
- [转动图模板](/document/product/266/11701#.E8.BD.AC.E5.8A.A8.E5.9B.BE.E6.A8.A1.E6.9D.BF)
- [指定时间点截图模板](/document/product/266/11702#.E6.8C.87.E5.AE.9A.E6.97.B6.E9.97.B4.E7.82.B9.E6.88.AA.E5.9B.BE.E6.A8.A1.E6.9D.BF)
- [采样截图模板](/document/product/266/11702#.E9.87.87.E6.A0.B7.E6.88.AA.E5.9B.BE.E6.A8.A1.E6.9D.BF)
- [雪碧图截图模板](/document/product/266/11702#.E9.9B.AA.E7.A2.A7.E5.9B.BE.E6.88.AA.E5.9B.BE.E6.A8.A1.E6.9D.BF)
- [视频加密模板](/document/product/266/9645)
- [鉴黄模版](/document/product/266/11701#.E9.A2.84.E7.BD.AE-ai-.E9.89.B4.E9.BB.84.E6.A8.A1.E6.9D.BF)

## 任务流

参数模板实现了对**单项**视频处理操作的参数封装，而任务流则是在参数模板的基础上，实现了对**一组**视频处理操作的整合。

- 任务流将单个视频的处理过程划分为一系列串行的**阶段**（如下图所示）；
- 每个阶段包含一组**子任务**，每一个子任务只负责一项原子化的视频处理操作，同一阶段内子任务的可以并发执行的；
- 开发者可以定义每个阶段固定执行哪些子任务；亦可灵活控制每一个阶段执行哪些子任务，实现视频处理流程的程序化控制，即：根据上一个阶段的处理结果决定下一个阶段采取何种视频处理操作。

![任务流各个阶段](//mc.qcloudimg.com/static/img/6319b1a7d78997d4585e86436d6cdcb8/image.png)

任务流本质上可以看做是描述如何对一组视频处理的配置或者脚本，点播系统提供两种任务流配置方式：
- [**JSON任务流**](#json.E4.BB.BB.E5.8A.A1.E6.B5.81)：以JSON配置来描述视频处理各个阶段分别包含哪些处理操作，不接受额外输入参数；适用于流程固定、不存在条件分支的视频处理。例如，所有视频都转出标清、高清、超清三路，且进行雪碧图截图。
- [**Lua任务流**](#lua.E4.BB.BB.E5.8A.A1.E6.B5.81)：以Lua脚本来描述各个阶段分别执行哪些视频处理操作，且可以接受额外输入参数；借助于Lua强大的逻辑表达能力，视频处理逻辑可以存在条件分支。例如，对于码率高于512kbps的视频，进行标清转码，否则不进行转码。

### 任务流模板

对于JSON任务流而言，任务流的内容即为一段JSON配置；对于Lua任务流而言，任务流的内容是一段Lua代码。

出于易用性与安全性的考虑，点播系统引入了任务流模板这一概念，即：使用一个短小的字符串来作为模板名称，模板的内容即为JSON配置或者Lua代码。使用任务流处理视频时，需要指明任务流模板名称而非任务流内容。

目前，点播系统暂时没有将自助配置任务流模板的能力开放，如果您存在自定义任务流模板的需求，请提需求工单。


<!-- 

点播系统提供了一组服务端API来管理任务流：

- 创建任务流模板；
- 更新任务流模板；
- 查询任务流模板列表与详情；
- 删除任务流模板。

> 注意：
> - 出于安全性考虑，点播系统暂不支持开发者自定义Lua任务流模板。 -->

### JSON任务流

JSON任务流是以JSON配置来描述视频处理各个阶段分别包含哪些处理操作，是一种最简单、最直接的视频处理逻辑编排方式。

<!-- 参见：JSON任务流模板参考。

TODO-leckie：完善超链接。 -->

### Lua任务流
Lua任务流以Lua 5.1脚本语言来描述各个阶段分别执行哪些视频处理操作，且可以接受额外输入参数。

> 注意：
> - 关于Lua 5.1可以参考：[Lua 5.1参考手册（英文）](https://www.lua.org/manual/5.1/)、[Lua 5.1参考手册（中文）](https://www.codingnow.com/2000/download/lua_manual.html)。

假设某一Lua任务流的名称为`MyFirstProcedure`，其对应的任务流内容为：


```lua
------------------------------------------
--- Lua任务流示例代码，模板名称：MyFirstProcedure
------------------------------------------

-- 定义任务流处理类
VodProcedure = NewProcedureClass()

-- 定义构造函数
function VodProcedure:constructor()
    -- ...
end

-- 定义视频处理阶段的操作
function VodProcedure:handleProcess()
    -- 该阶段的视频处理操作集合
    local processActionSet = ProcessActionSet:new()

    -- 转码操作
    local transcodeAction = TranscodeAction:new()

    -- 转码操作
    -- ...

    processActionSet:addAction(transcodeAction)
    return processActionSet
end

-- 任务流其他阶段的操作
-- ...

-- 任务流入口函数，支持输入一个参数，该参数为该任务的优先级
function CreateProcedure(priority)
    local procedure = VodProcedure:new()

    if type(priority) == 'number' then
        procedure.setPriority(priority)
    end

    return procedure
end
```

Lua任务流的代码结构如下：

- 任务流的处理逻辑是由一个类来实现（示例代码中的`VodProcedure`类），该类定义了任务流在各个阶段分别执行哪些操作；
- 任务流实现类（即示例代码中的`VodProcedure`类）必须通过`NewProcedureClass`来创建类，以确保其继承自点播系统內建的`BaseProcedure`类；
- 任务流实现类可以定义一个构造函数`constructor`，以便完成必要的初始化操作；
- Lua脚本中必须提供一个名为`CreateProcedure`的入口函数，该函数是一个工厂函数，返回一个任务流实现类的具体实例（即对象）；
- 入口函数`CreateProcedure`可以接受额外的输入参数（示例代码中传入了参数`priority`）。

在使用Lua任务流来处理视频时，必须借助于Lua任务流的模板名称来处理。我们约定：
- 如果仅传递Lua任务流模板名称，则意味着调用入口函数`CreateProcedure`时不带任何参数；
- 如果在传递Lua任务流模板名称时，在其后增加`()`，则可以在`()`中传递参数给任务流（即：类似函数调用的方式）；参数的传递方式与Lua语言中函数传递参数的方式相同，参数之间以逗号分隔，支持输入Number、String、Boolean、Table四种类型的参数。

举例：调用[ProcessFileByProcedure](/document/product/266/9045)接口，通过服务端API调用任来处理视频：

示例一：调用MyFirstProcedure来处理视频，不传递参数。
<pre>
https://vod.api.qcloud.com/v2/index.php?Action=ProcessFileByProcedure
&fileId=12345
&procedure=MyFirstProcedure
&COMMON_PARAMS
</pre>

示例二：调用MyFirstProcedure来处理视频，传递优先级参数（设定该任务的优先级为5）。
<pre>
https://vod.api.qcloud.com/v2/index.php?Action=ProcessFileByProcedure
&fileId=12345
&procedure=MyFirstProcedure(5)
&COMMON_PARAMS
</pre>

## 任务流各阶段介绍

点播系统将任务流划分为如下一组阶段，从第一个阶段到最后一个阶段依次顺序执行。每个阶段内的操作互不依赖，并发执行。某个阶段亦可能不包含任何操作。

### 视频生成
视频生成过程决定后续所有处理过程所操作的源视频。有如下几种方式生成源视频：

- 指定媒资库中已有视频（FileID不变）；
- 对媒资库中已有视频进行剪辑，生成新视频（生成新的FileID）；
- 从其他平台远程拉取视频到点播平台（生成新的FileID）。

### 获取元信息

获取视频的元信息，例如长度、码率、分辨率、编码方式等。在Lua任务流中，可以依照视频元信息来控制后续阶段的视频处理操作。

获取视频元信息成功后，其结果将被写入到媒资系统中，可以通过[服务端API：获取视频信息(GetVideoInfo)](/document/product/266/8586)接口查询得到。

### AI 视频鉴黄

AI 视频鉴黄可以识别出视频是否涉及色情内容，并由审核结果决定任务流的后续执行阶段。例如，开发者可以设定“发现视频涉黄之后立即终止处理”，亦可设定“发现视频涉黄之后继续执行处理”。具体请查看：

* [AI 鉴黄](/document/product/266/11701#.E4.BD.BF.E7.94.A8-ai-.E9.89.B4.E9.BB.84)

### 人工视频审核

所谓人工视频审核，是指点播系统可以将 AI 鉴黄中识别出的疑似违规内容以截图 URL 的形式提供给开发者，由专职的视频审核人员进行复核。开发者可以根据人工审核结果决定如何处理视频。具体请查看：

* [人工审核](/document/product/266/11701#ai-.E9.89.B4.E9.BB.84.E9.85.8D.E5.90.88.E4.BA.BA.E5.B7.A5.E5.AE.A1.E6.A0.B8)

### 视频处理

对视频进行处理，包括：
- [转码](/document/product/266/11701#.E8.A7.86.E9.A2.91.E8.BD.AC.E7.A0.81)（包含[水印](/document/product/266/11701#.E8.A7.86.E9.A2.91.E6.B0.B4.E5.8D.B0)、[加密](/document/product/266/9638)、[转封装](/document/product/266/11701#.E8.A7.86.E9.A2.91.E8.BD.AC.E5.B0.81.E8.A3.85)等功能）；
- [转动图](/document/product/266/11701#.E9.A2.84.E7.BD.AE.E8.BD.AC.E5.8A.A8.E5.9B.BE.E6.A8.A1.E6.9D.BF)
- [指定时间点截图](/document/product/266/11702#.E6.8C.87.E5.AE.9A.E6.97.B6.E9.97.B4.E7.82.B9.E6.88.AA.E5.9B.BE)；
- [使用指定时间点截图作为封面](/document/product/266/11702#.E4.BD.BF.E7.94.A8.E6.8C.87.E5.AE.9A.E6.97.B6.E9.97.B4.E7.82.B9.E6.88.AA.E5.9B.BE.E4.BD.9C.E4.B8.BA.E5.B0.81.E9.9D.A2)；
- [采样截图](/document/product/266/11702#.E9.87.87.E6.A0.B7.E6.88.AA.E5.9B.BE)；
- [雪碧图截图](/document/product/266/11702#.E9.9B.AA.E7.A2.A7.E5.9B.BE(imagesprite))。

以上视频处理操作的输出结果都将被写入到媒资系统中，可以通过[服务端API：获取视频信息(GetVideoInfo)](/document/product/266/8586)接口查询得到。

### 视频分发

视频分发环节包括：
- 微信视频上传。

## 使用任务流处理视频

开发者可以通过如下几种方式使用任务流来进行视频处理：

- 处理已有视频
- 在上传视频时，指定视频处理方式，包括：
    - 客户端上传时指定任务流
    - 服务端上传时指定任务流
    - 离线拉取视频时指定任务流
    - 在直播录制时指定任务流
- 生成视频并使用任务流处理

### 处理已有视频
#### 通过控制台处理已有视频
文档完善中。

#### 通过服务端API处理已有视频

参见：
- 服务端API：[使用任务流处理视频(RunProcedure)](/document/product/266/11030)
- 服务端API：[对视频文件进行处理(ProcessFile)](/document/product/266/9642)

注意：
> 两个接口之间的区别在于：
>
> - `ProcessFile` 只能对已有视频进行处理（即：没有“视频生成”阶段，不会生成新的FileID）；`RunProcedure` 则可以生成新的视频；
> - `RunProcedure` 的输入都是任务流模板名称，支持JSON任务流和Lua任务流；
> - `ProcessFile` 仅支持任务流的“视频处理”阶段，其输入参数不是任务流模板名称，而是具体的视频处理参数模板。


### 客户端上传时指定任务流
* [客户端上传时指定任务流](https://cloud.tencent.com/document/product/266/9219#.E4.B8.8A.E4.BC.A0.E6.97.B6.E6.8C.87.E5.AE.9A.E8.A7.86.E9.A2.91.E5.A4.84.E7.90.86.E6.96.B9.E5.BC.8F)

### 服务端上传时指定任务流
* [服务端上传时指定任务流](https://cloud.tencent.com/document/product/266/9759#.E4.B8.8A.E4.BC.A0.E6.97.B6.E6.8C.87.E5.AE.9A.E6.8C.87.E5.AE.9A.E8.A7.86.E9.A2.91.E5.A4.84.E7.90.86.E6.96.B9.E5.BC.8F)

### 离线拉取视频时指定任务流
文档完善中。

### 在直播录制时指定任务流
文档完善中。

### 生成视频并使用任务流处理
* [生成视频并使用任务流处理](https://cloud.tencent.com/document/product/266/11030)

## 获取任务流执行结果

所谓任务流执行结果，是指各项视频处理操作的输出物，例如转码、截图输出文件的路径，视频鉴黄的结果等。
开发者可以通过如下几种方式获取任务流的执行结果：
1. 通过任务流事件通知感知任务流执行结果（或状态变更）：参见[事件通知](#.E4.BA.8B.E4.BB.B6.E9.80.9A.E7.9F.A5)；
1. 通过状态查询接口获取任务流执行结果：参见[状态查询](#.E4.BB.BB.E5.8A.A1.E7.AE.A1.E7.90.86)；
1. 通过媒资管理接口获取任务流的输出结果：任务流中部分子任务的操作结果会写入媒资系统中，可以通过[服务端API：获取视频信息(GetVideoInfo)](/document/product/266/8586)获取视频的转码、截图等操作的结果。

## 事件通知与任务管理

使用任务流处理视频本质上属于离线操作。通过任务流发起视频处理操作之后，该操作将会作为一个离线任务在点播后台执行，点播后台会给调用方返回任务ID。

开发者可以通过事件通知机制来感知任务的执行，亦可通过任务管理机制查询某任务的执行状态。参见[事件通知与任务管理](/document/product/266/7829)。

### 事件通知

对于通过任务流发起的视频处理任务，事件通知分为两种：
1. 任务流执行状态变更通知：任务流各阶段中每个子任务执行完毕，都会触发事件通知（例如：每完成一个规格的转码，都会触发通知）；适用于需要快速获取视频处理结果的场景；
1. 任务流执行结束通知：不关注任务执行的中间过程，只有当整个任务执行结束之后，才触发一次事件通知。

参见：[任务流状态变更通知](/document/product/266/9636)。

### 任务管理

可以根据任务ID查询任务流的执行状态（排队中/执行中/已结束）以及结果（即：各项子操作的输出结果）。

参见：[任务管理](/document/product/266/7829#.E4.BB.BB.E5.8A.A1.E7.AE.A1.E7.90.86)。

## 点播预置任务流模板

### QCVB_SimpleProcessFile

该任务流模板为Lua任务流，支持如下几种简单的视频处理操作：
- 视频转码，包括：
    - 通过任务流输入参数指定转码输出格式；
    - 使用控制台默认转码输出格式；
- 在转码时打水印；
- 截取首帧作为视频封面；
- 采样截图。

该任务流支持四个输入参数，其入口函数签名如下：

```lua
------------------------------------------
--- 预置任务流QCVB_SimpleProcessFile的入口函数
------------------------------------------
function CreateProcedure(transcodeDefinition，watermarkDefinition，
    coverBySnapshotDefinition，sampleSnapshotDefinition)
```

各参数含义分别如下：
<table>
    <tr>
        <th>
            参数
        </th>
        <th>
            说明
        </th>
    </tr>
    <tr>
        <td>
            transcodeDefinition
        </td>
        <td>
            <p>转码控制参数，支持以下几种输入方式：</p>
            <li>使用控制台默认转码设置进行转码：将该参数填写为整数1；</li>
            <li>使用指定转码模板ID进行转码：将该参数填写为一个整数数组，数组中的每个元素为目标转码模板ID；</li>
            <li>不转码：将该值填写为nil或者0。</li>
        </td>
    </tr>
    <tr>
        <td>
            watermarkDefinition
        </td>
        <td>
            <p>水印控制参数，支持以下几种输入方式：</p>
            <li>使用控制台默认水印设置进行转码：将该参数填写为整数1；</li>
            <li>使用指定水印ID进行转码：将该参数填写为水印ID（整数）；</li>
            <li>不打水印：将该值填写为nil或者0。</li>
        </td>
    </tr>
    <tr>
        <td>
            coverBySnapshotDefinition
        </td>
        <td>
            <p>截取首帧作为封面控制参数，支持以下几种输入方式：</p>
            <li>使用指定时间点截图模板截取首帧，并将其设置为封面：将该参数填写为截图模板ID（整数）；</li>
            <li>不截取首帧作为封面：将该值填写为nil或者0。</li>
        </td>
    </tr>
    <tr>
        <td>
            sampleSnapshotDefinition
        </td>
        <td>
            <p>采样截图控制参数，支持以下几种输入方式：</p>
            <li>使用采样截图模板进行截图：将该参数填写为采样截图模板ID（整数）</li>
            <li>不进行采样截图：将该值填写为nil或者0。</li>
        </td>
    </tr>
</table>


#### 示例：使用预置任务流`QCVB_SimpleProcessFile`处理视频

示例1：使用控制台默认转码、水印参数进行转码：
<pre>
QCVB_SimpleProcessFile(1, 1)
</pre>

示例2：截取首帧作为封面，使用截图模板10，不进行其他处理：
<pre>
QCVB_SimpleProcessFile(0, 0, 10)
</pre>

示例3：使用转码模板10，20进行转码；转码过程使用水印模板150设置水印；使用截图模板10截取首帧设置封面；使用采样截图模板10进行采样截图：
<pre>
QCVB_SimpleProcessFile({10, 20}, 150, 10, 10)
</pre>

### QCVB_ProcessUGCFile

该任务流模板为 Lua 任务流，支持如下几种视频处理操作：

- 视频转码，包括：
    - 通过任务流输入参数指定转码输出格式；
    - 使用控制台默认转码输出格式；
- 在转码时打水印；
- 截取首帧作为视频封面；
- AI 鉴黄。

该任务流支持四个输入参数，其入口函数签名如下：

```lua
------------------------------------------
--- 预置任务流QCVB_SimpleProcessFile的入口函数
------------------------------------------
function CreateProcedure(transcodeDefinition，watermarkDefinition，coverBySnapshotDefinition，aiReviewDefinition)
```

各参数含义分别如下：
<table>
    <tr>
        <th>
            参数
        </th>
        <th>
            说明
        </th>
    </tr>
    <tr>
        <td>
            transcodeDefinition
        </td>
        <td>
            <p>转码控制参数，支持以下几种输入方式：</p>
            <li>使用控制台默认转码设置进行转码：将该参数填写为整数 1；</li>
            <li>使用指定转码模板 ID 进行转码：将该参数填写为一个整数数组，数组中的每个元素为目标转码模板 ID；</li>
            <li>不转码：将该值填写为 nil 或者 0。</li>
        </td>
    </tr>
    <tr>
        <td>
            watermarkDefinition
        </td>
        <td>
            <p>水印控制参数，支持以下几种输入方式：</p>
            <li>使用控制台默认水印设置进行转码：将该参数填写为整数 1；</li>
            <li>使用指定水印 ID 进行转码：将该参数填写为水印 ID（整数）；</li>
            <li>不打水印：将该值填写为 nil 或者 0。</li>
        </td>
    </tr>
    <tr>
        <td>
            coverBySnapshotDefinition
        </td>
        <td>
            <p>截取首帧作为封面控制参数，支持以下几种输入方式：</p>
            <li>使用指定时间点截图模板截取首帧，并将其设置为封面：将该参数填写为截图模板 ID；</li>
            <li>不截取首帧作为封面：将该值填写为 nil 或者 0。</li>
        </td>
    </tr>
    <tr>
        <td>
            aiReviewDefinition
        </td>
        <td>
            <p>视频鉴黄控制参数，支持以下几种输入方式：</p>
            <li>使用 AI 鉴黄模板进行鉴黄：将该参数填写为鉴黄模板 ID（整数）</li>
            <li>不进行采样截图：将该值填写为 nil 或者 0。</li>
        </td>
    </tr>
</table>


#### 示例：使用预置任务流 `QCVB_ProcessUGCFile` 处理视频

示例1：使用转码模板 10，20 进行转码；转码过程使用水印模板 150 设置水印；使用截图模板 10 截取首帧设置封面；使用鉴黄模板 10 进行 AI 鉴黄：
<pre>
QCVB_ProcessUGCFile({10,20},150,10,10)
</pre>

<!-- ### TODO：转封装 -->