# 通用

## useExpression

<Tag theme="primary" className="apa-font-16">运行态</Tag>

**参数**

解析表达式，以当前组件的上下文解析表达式

- `{string} expression` 表达式文本
- `{Function} subscriber` 可选，监听函数。当表达式依赖的数据变化时，该函数会自动调用

**返回值**

返回表达式解析的结果

**示例**

``` ts
const result = SDK.useExpression('$component.Input1.state.value', (result) => {
  // result 是表达式结果
  // 该函数会在组件Input的值（state.value）变化时自动调用
});
```

## useExpressionWithContext

<Tag theme="primary" className="apa-font-16">运行态</Tag>

解析表达式，以指定的数据记录上下文解析表达式。用法与`useExpression`相似，区别是可以自定义表达式运行时解析的数据记录上下文。

**参数**

- `{string} expression` 表达式文本
- `{ExpressionContext} context` 单条数据记录上下文
- `{Function} subscriber` 可不传，监听函数。当表达式依赖的数据变化时，该函数会自动调用

``` ts
type ExpressionContext = {
  recordId: string; // 数据记录ID
  entityCode: string; // 对象模型编码
  recordData: Record<string, any>; // 对象单条数据
}
```

**返回值**

返回表达式解析的结果

**示例**

``` ts
const result = SDK.useExpressionWithContext('#name', {
  recordId: '',
  entityCode: '10000',
  recordData: {
    name: 'abc',
  },
}, (result) => {
  // result 是表达式结果
  // 该函数会在上下文中，name的字段值变化时自动调用
});
```

## useVariable

<Tag theme="primary" className="apa-font-16">运行态</Tag>

**参数**

解析表达式，以当前组件的上下文解析表达式

- `{string} variableType` 变量类型 `'global' | 'page' | 'input' | 'system'`
- `{string} variableKey` 变量名称
- `{Function} subscriber` 可选，监听函数。当变量变化时，该函数会自动调用

变量类型

- `global` 全局变量
- `page` 页面变量
- `input` 入参变量
- `system` 系统变量

**返回值**

返回变量当前值

**示例**

``` ts
// 解析系统变量当前用户的值
const currentUser = useVariable('system', 'currentUser');
// 解析入参变量中id的值（url中的id参数值）
const id = useVariable('input', 'id');
// 解析页面变量中的myToken
const myToken = useVariable('page', 'myToken', (res) => {
  // 变量值变化时，此函数会自动调用
});
```

## useParser

<Tag theme="primary" className="apa-font-16">运行态</Tag>

**返回值**

获取解析器，解析当前页面上的动态数据

- `parseComponentValue` 解析组件的值
- `parseVariableValue` 解析变量的值
- `parseFileValueAsync` 解析动态文件的URL

**示例**

`parseComponentValue`

``` ts
const { parseComponentValue } = useParser();
// 解析组件Input1的值
const inputValue = parseComponentValue('Input1', 'state', 'value');
```

`parseVariableValue`

``` ts
const { parseVariableValue } = useParser();
// 解析系统变量当前用户的值
const currentUser = parseVariableValue('system', 'CurrentUser');
```

`parseFileValueAsync`

``` ts
const { parseFileValueAsync } = useParser();
// 根据文件ID, 解析出文件的URL
parseFileValueAsync('1468505443100905529').then((fileUrl) => {
  // fileUrl是文件url
});
```

## useDataSource

<Tag theme="primary" className="apa-font-16">运行态</Tag>

**用法**

`useDataSource`可以将`props`中获取来的`DataSource`类型的值，转化为可执行方法。

**参数**

- `{DataSource} dataSource` 数据源类型，由`DataSource`组件选择并生成。
- `{Function} subscriber` 可不传，`subscriber`函数次DataSource的参数变化时执行, 可以保证数据的动态刷新，例如数据筛选条件、流程入参。

**返回值**

- `fetchData` 一个可执行方法，返回Promise。根据数据源类型，返回不同的响应结果。

**示例**

``` ts
const { fetchData } = SDK.useDataSource(dataSource);
// 或
// -----------------------------------------
SDK.useDataSource(dataSource, (fetchData) => {
  // 这个回调函数会在每次DataSource的参数变化时执行
  // 可以保证数据的动态刷新
  // 如筛选条件、流程入参
  console.log("数据源DataSource参数变化，请重新执行fetchData");
});
```


## useEventBus

<Tag theme="primary" className="apa-font-16">运行态</Tag>

**用法**

`useEventBus`创建或获取一个`EventBus`，根据`namespace`来区分生效空间。

**参数**

`{string} namespace` 定义`EventBus`生效的命名空间, 根据传入的`namespace`获取`EventBus`; 如果未获取到对应`EventBus`则会创建新的`EventBus`。

**返回值**

`EventBus`类型对象实例。

- `on(event: string, callback: Function): Function` 监听一个事件，返回一个`cancel`的方法，`cancel`方法执行可以取消监听。
- `emit(event: string, data: any): void` 触发一个事件，并携带数据
- `off(event: string, callback: Function): Function` 取消监听事件，传入监听函数取消对应的监听

**示例**

注意：在使用`EventBus`时，`on`创建的监听，记得在组件生命周期结束时取消监听，防止造成内存泄露。

``` ts
const { on } = SDK.useEventBus("example");

useEffect(() => {
  const cancel = on("example_showModal", () => {
    setVisible(true);
  });
  return () => cancel();
}, [on]);
```

## useCanvas

<Tag theme="primary" className="apa-font-16">运行态</Tag>
<Tag theme="primary" className="apa-font-16">设计态</Tag>

**用法**

`useCanvas`可以获取到当前画布的信息，如客户端信息，页面编码等，无参数


**返回值**

`Canvas`类型对象实例。

- `{'pc'|'mobile'|'pad'} size` 当前页面尺寸类型，区分响应式客户端信息。PC端、移动端、PAD平板端。
- `{'run'|'design'} mode` 标识当前画布为设计态，还是运行态。

**示例**

``` ts
const { size, mode } = SDK.useCanvas();
const sizeText = {
  pc: "PC端",
  mobile: "移动端",
  pad: "Pad",
}[mode];
return (
  <div>
    <h3>当前画布为：{mode === "design" ? "设计态" : "运行态"}</h3>
    <p>当前终端尺寸: {sizeText}</p>
    {size === "mobile" ? (
      <MobileDemo {...props} mode={mode} />
    ) : (
      <PCDemo {...props} mode={mode}></PCDemo>
    )}
  </div>
);
```