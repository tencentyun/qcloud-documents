

云开发低码的数据源提供了数据集合本身的存储以及操纵数据的各种方法，本质上是一系列操作数据的方法的集合。低码平台提供了数据源管理功能，可以创建、管理多个数据源。


## 数据源分类

根据数据源目的及存储方式的不同，数据源可分为下面两类：

| 数据源分类 | 说明 | 
|---------|---------|
| 云端集成 | 用于将第三方已有的数据源集成到底码平台（目前入口暂时隐藏） |
| 数据库数据源 | 使用云开发数据库存储数据 |


>?数据源需要有一个标识，以方便数据源在底码编辑器及低代码中使用，故这个标识应当遵循一般代码变量命名规则， 命名时应当具有一定可读性。





## 数据源方法目的分类

根据数据源方法的目的及实际使用场景，可将数据源方法分为下述五类：


| 数据源方法分类 | 对应方法 | 说明                                                         |
| -------------- | -------- | ------------------------------------------------------------ |
| 查询列表       | getList  | 返回多条数据记录，适用于前端需要展示列表、表格等的场景       |
| 查询单条       | getItem  | 返回单条数据记录，适用于前段需要展示详情、信息卡片的场景，前端编辑数据的场景也会需要使用该类型的方法获取要编辑的数据 |
| 修改数据       | update   | 更新已存在的数据记录，例如更新个人信息，修改已发布的文章等等 |
| 删除数据       | delete   | 删除（也包括多选删除）已有数据记录，例如多选删除             |
| 新增数据       | create   | 添加新的数据记录，例如注册用户，发布文章等等                 |



数据库类型的数据源已预置实现了 "getList" 、"getItem" 、"update" 、  "delete" 、 "create"  方法，与上述五种目的一一对应。用户在新建、编辑数据库类型的数据源时，可选择是否启用上述方法。

>?同数据源一样，数据源方法也需要一个标识，以方便使用。

## 数据源方法实现

### 实现分类

根据数据源方法的实现方式的不同，可分为云函数和本地函数。


<dx-tabs>
::: 云函数
基于云开发的云函数能力封装，需使用 JS 语法编写，最终会运行在服务器端的 Nodejs 环境中，拥有服务器端权限。相比本地函数，权限更大。云函数必须使用 `module.exports` 导出。
云函数编写形式：
<dx-codeblock>
:::  js
module.exports = async function (params，context) {
	...
}
:::
</dx-codeblock>
- 参数 params 为函数接收的参数，context 则为平台注入的对象，包含辅助工具，方便云函数的开发。
- 函数处理中发现错误，可以直接 `throw new Error('xxxx')` 来抛出错误，也可以使用 `throw new TCBError(code，'msg')` 抛出错误并自定义错误代码。
:::
::: 本地函数
需使用 JS 语法编写，根据使用该数据源的应用发布形式的不同，执行环境也会不同：
- 若应用发布为 H5，则数据源的本地函数将会在浏览器端执行，函数受浏览器端的环境及安全策略限制。
- 若应用发布为小程序，则本地函数将会在小程序中执行，函数受小程序的环境及安全策略限制。
  本地函数必须使用 `export default` 导出。

本地函数编写形式：
<dx-codeblock>
:::  js
export default async function (params，context) {
	...
}
:::
</dx-codeblock>
- 参数 params 为函数接收的参数，context 则为平台注入的对象，包含辅助工具，方便云函数的开发。
- 函数处理中发现错误，可以直接 `throw new Error('xxxx')` 来抛出错误，也可以使用 `throw new TCBError(code，'msg')` 抛出错误并自定义错误代码。
:::
</dx-tabs>






### 数据源方法的入参及出参

不论是云函数或是本地函数，均需要描述函数的入参和出参的数据结构，以方便底码编辑器使用该方法。

- 入参即函数的 params。
- 出参即函数返回结果，即 return 语句返回的内容。

**实际调用数据源方法时**，底码框架将对返回的结果进行包装，实际输出结果结构为：


<dx-codeblock>
:::  ts
interface IResponse {
	// 0 即表示成功，其他情况为失败，使用 Error 抛出的错误，code 为 -1
	//   使用 TCBError 抛出的错误，code 即为其指定的值
	code： number
	// 结果，即 数据源函数的出参
	data： IResult
	// 错误信息，失败时会有该值
	message?： string
}
:::
</dx-codeblock>



## 数据源的更新及发布

数据源的改动（创建、更新、删除）只有在使用该数据源的应用发布时，才会真正生效。



>!
>1. 数据源若被多个应用使用，则需要每一个使用该数据源的应用重新发布，方可使用最新的数据源。
>2. 应用本身区分预览和发布两种发布场景，两种场景使用的数据源亦互不影响。即：
>  - 若需预览时使用最新的数据源，则需重新预览一次应用。
>  - 若希望已上线发布的应用使用最新的数据源，则重新发布应用即可。


## 数据源在低码应用开发时的使用

目前有两种使用数据源的方式： 低代码编辑器和数据源变量。



<dx-tabs>
::: 低代码编辑器
底码框架会在底码运行环境中注入全局对象以方便的访问不同的数据源及数据源的方法。 

使用形式如下：
```plaintext
app.dataSources.<数据源标识>.<数据源方法名称>(params)
```

>!数据源方法皆为异步。

在低代码编辑器中则可以在全局或者页面的生命周期、handler 中使用上述形式使用数据源。

例如，在自定义 handler  `createUser`  中调用“用户数据源（user）”的新建（create）方法：
<dx-codeblock>
:::  js
export default async function (params) {
	try {
		const resp = await app。dataSources。user。create(params)
		if (!resp。code) {
			console。log('成功')
		} else {
			console。log('失败 ' + resp。meesage)
		}
	} catch(e) {
		console。log('未知错误' + e。message)
	}	
}
:::
</dx-codeblock>
:::
::: 数据源变量
在底码编辑器中，还可以通过变量管理中通过添加数据源变量的方式来更方便的使用数据源。

数据源变量定义好后，可通过下边两种方式使用：

- 方式1：在组件编辑时，绑定数据源变量的值。
- 方式2：在低代码编辑器中使用 `app.dataset.state.<全局数据源变量标识>`  和 `$page.dataset.state.<页面数据源变量标识>` ，使用全局和页面的数据源变量。
:::
</dx-tabs>

